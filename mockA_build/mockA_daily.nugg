<?xml version="1.0" encoding="utf-8"?>
<nugget name="C:\Users\Uwe\Documents\GitHub\mockA\mockA_build\mockA_daily.nugg">
 <CLAS CLSNAME="ZCL_MOCKA_HELPER_MOCKER" VERSION="1" LANGU="E" DESCRIPT="Helper Klasse für ZCL_MOCKA_MOCKER" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <textPool>
   <language SPRAS="D">
    <textElement ID="I" KEY="001" ENTRY="Es können keine weiteren Subroutine-Pools erzeugt werden" LENGTH="100 "/>
   </language>
  </textPool>
  <method CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" SCONAME="IT_CODE" VERSION="1" LANGU="D" DESCRIPT="Tabelle von Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING_TABLE"/>
   <parameter CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" SCONAME="EV_PROG" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" SCONAME="EV_SUBRC" VERSION="1" LANGU="D" DESCRIPT="Rückgabewert von ABAP-Anweisungen" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <parameter CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" SCONAME="EV_MESSAGE" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <source>METHOD generate_subroutine_pool.
  FREE: ev_prog,
        ev_subrc,
        ev_message.

  CATCH SYSTEM-EXCEPTIONS generate_subpool_dir_full = 9.
    GENERATE SUBROUTINE POOL it_code NAME ev_prog MESSAGE ev_message.
    IF sy-subrc IS NOT INITIAL.
      ev_subrc = sy-subrc.
    ENDIF.
  ENDCATCH.
  IF sy-subrc = 9.
    ev_subrc = sy-subrc.
    ev_message = text-001.
  ENDIF.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_MOCKA_MOCKER" VERSION="1" LANGU="E" DESCRIPT="implements the creator of mock objects" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TY_S_METHODS" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" EXPOSURE="1" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="6 " SRCCOLUMN2="127 " TYPESRC_LENG="124 " TYPESRC="BEGIN OF ty_s_methods,    name TYPE seocpdname,    method_mocker TYPE REF TO ZIF_MOCKA_MOCKER_method,    END OF ty_s_methods"/>
  <types CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TY_T_METHODS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="8 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="42 " TYPESRC_LENG="39 " TYPESRC="ty_t_methods TYPE TABLE OF ty_s_methods"/>
  <types CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TY_S_GENERATED_CLASS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="120 " TYPESRC_LENG="117 " TYPESRC="BEGIN OF TY_S_GENERATED_CLASS,    name type SEOCLSNAME,    technical_name TYPE string,    end of ty_s_generated_class"/>
  <friends CLSNAME="ZCL_MOCKA_MOCKER" REFCLSNAME="ZCL_MOCKA_MOCKER_METHOD" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <implementing CLSNAME="ZCL_MOCKA_MOCKER" REFCLSNAME="ZIF_MOCKA_MOCKER" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <textPool>
   <language SPRAS="E"/>
  </textPool>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <forwardDeclaration>SEOS</forwardDeclaration>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MO_OBJECTDESCR" VERSION="1" LANGU="D" DESCRIPT="Run Time Type Services" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_ABAP_OBJECTDESCR" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MT_CONSTRUCTOR_PARAMETERS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_PARMBIND_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MT_GENERATED_CLASSES" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="6 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="19 " SRCCOLUMN1="4 " SRCROW2="19 " SRCCOLUMN2="58 " TYPESRC_LENG="55 " TYPESRC="mt_generated_classes TYPE TABLE OF ty_s_generated_class"/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MT_METHOD_MOCKS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER=&gt;TY_T_METHOD_MOCKS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MV_GENERATED_CLASS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MV_INTERFACE" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MV_IS_INTERFACE_MOCK" VERSION="1" LANGU="D" DESCRIPT="Ist ein Interface zu mocken?" EXPOSURE="1" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MV_MOCK_COUNT" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~GENERATE_MOCKUP">
   <source>METHOD zif_mocka_mocker~generate_mockup.
  DATA lv_has_returning_parameter TYPE abap_bool VALUE abap_false.
  DATA lv_has_exporting_parameter TYPE abap_bool VALUE abap_false.
  DATA lv_has_changing_parameter TYPE abap_bool VALUE abap_false.

  DATA lt_constructor_parameters LIKE mt_constructor_parameters.
  DATA ls_constructor_parameter LIKE LINE OF mt_constructor_parameters.

  IF mv_generated_class IS NOT INITIAL.
    ls_constructor_parameter-name = &apos;IO_MOCKER&apos;.
    ls_constructor_parameter-kind = &apos;E&apos;.
    GET REFERENCE OF me INTO ls_constructor_parameter-value.
    INSERT ls_constructor_parameter INTO TABLE lt_constructor_parameters.
    INSERT LINES OF mt_constructor_parameters INTO TABLE lt_constructor_parameters.
    CREATE OBJECT ro_mockup
      TYPE
        (mv_generated_class)
      PARAMETER-TABLE
        lt_constructor_parameters.
    RETURN.
  ENDIF.
  FIELD-SYMBOLS &lt;ls_method_mock&gt; LIKE LINE OF mt_method_mocks.
  LOOP AT mt_method_mocks ASSIGNING &lt;ls_method_mock&gt;.
    &lt;ls_method_mock&gt;-method_mock-&gt;finalize_current_method_sign( ).
  ENDLOOP.

  ADD 1 TO mv_mock_count.
  DATA lt_code  TYPE TABLE OF string.
  DATA lt_temp_code  TYPE TABLE OF string.
  DATA lv_prog  TYPE string.
  DATA lv_line TYPE string.
  FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mo_objectdescr-&gt;methods.
  FIELD-SYMBOLS &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_classname TYPE seoclsname.
  DATA: lv_exception TYPE seoclsname.
  DATA ls_method_key TYPE seocmpkey.
  DATA lv_message TYPE string.
  DATA lt_exceptions TYPE seos_exceptions_r.
  FIELD-SYMBOLS &lt;ls_exception&gt; TYPE vseoexcep.

  DATA lv_inheriting_from TYPE string.
  DATA lv_generate_method TYPE abap_bool.
  DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
  DATA lv_code_redefinition TYPE string.
  DATA lv_string TYPE string.
  DATA lv_is_class_based_exception TYPE abap_bool.

  APPEND `program.`                     TO lt_code.
  lv_string = mv_mock_count.
  CONCATENATE &apos;LCL_IMPL&apos; lv_string INTO lv_string.
  lv_classname = lv_string.
  IF mv_is_interface_mock = abap_false.
    CONCATENATE &apos;INHERITING FROM&apos; mv_interface INTO lv_inheriting_from SEPARATED BY space.
  ENDIF.
  CONCATENATE &apos;CLASS&apos; lv_classname &apos;DEFINITION&apos; lv_inheriting_from &apos;.&apos; INTO lv_line SEPARATED BY space.
  APPEND lv_line TO lt_code.
  APPEND &apos;PUBLIC SECTION.&apos; TO lt_code.
  IF mv_is_interface_mock = abap_true.
    CONCATENATE &apos;INTERFACES&apos; mv_interface &apos;.&apos; INTO lv_line SEPARATED BY space.
    APPEND lv_line TO lt_code.
  ELSE.

    LOOP AT mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WHERE is_class = abap_false.
      CLEAR: lv_has_changing_parameter, lv_has_exporting_parameter, lv_has_returning_parameter.
      lv_generate_method = abap_false.
      lo_mocker_method = resolve_method( &lt;ls_method&gt; ).
      IF lo_mocker_method IS NOT INITIAL.
        lv_generate_method = lo_mocker_method-&gt;has_registered_call_pattern( ).
      ENDIF.
      IF lv_generate_method = abap_false.
        CONTINUE.
      ELSE.
        lv_code_redefinition = &apos;REDEFINITION&apos;.
      ENDIF.

*     create method stub
      lv_line = &lt;ls_method&gt;-name.

      CONCATENATE &apos;METHODS&apos; lv_line lv_code_redefinition &apos;.&apos; INTO lv_line SEPARATED BY space.
      APPEND lv_line TO lt_code.
    ENDLOOP.
  ENDIF.

  APPEND &apos;METHODS constructor IMPORTING !io_mocker TYPE REF TO ZIF_MOCKA_MOCKER&apos; TO lt_code.

  READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = &apos;CONSTRUCTOR&apos;.
  IF sy-subrc = 0.
    CLEAR: lt_temp_code.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;I&apos;.
      READ TABLE mt_constructor_parameters TRANSPORTING NO FIELDS WITH KEY name = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        CONCATENATE &lt;ls_parameter&gt;-name &apos;TYPE ANY&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_temp_code.
      ENDIF.
    ENDLOOP.
    IF lt_temp_code IS NOT INITIAL.
      APPEND LINES OF lt_temp_code TO lt_code.
    ENDIF.

    CLEAR: lt_temp_code.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
      READ TABLE mt_constructor_parameters TRANSPORTING NO FIELDS WITH KEY name = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        CONCATENATE &lt;ls_parameter&gt;-name &apos;TYPE ANY&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_temp_code.
      ENDIF.
    ENDLOOP.
    IF lt_temp_code IS NOT INITIAL.
      APPEND &apos;CHANGING&apos; TO lt_code.
      APPEND LINES OF lt_temp_code TO lt_code.
    ENDIF.
  ENDIF.
  APPEND &apos;.&apos; TO lt_code.

  APPEND &apos;PROTECTED SECTION.&apos; TO lt_code.
  APPEND &apos;DATA: mo_mocker TYPE REF TO ZIF_MOCKA_MOCKER.&apos; TO lt_code.
  APPEND &apos;ENDCLASS.&apos; TO lt_code.

  CONCATENATE &apos;CLASS&apos; lv_classname &apos;IMPLEMENTATION.&apos; INTO lv_line SEPARATED BY space.
  APPEND lv_line TO lt_code.

  APPEND &apos;METHOD constructor.&apos; TO lt_code.
  IF mv_is_interface_mock = abap_false.
    APPEND &apos;call method super-&gt;constructor&apos; TO lt_code.
    READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = &apos;CONSTRUCTOR&apos;.
    IF sy-subrc = 0.
      CLEAR: lt_temp_code.
      LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;I&apos;.
        READ TABLE mt_constructor_parameters TRANSPORTING NO FIELDS WITH KEY name = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          CONCATENATE &lt;ls_parameter&gt;-name &apos;=&apos; &lt;ls_parameter&gt;-name INTO lv_line SEPARATED BY space.
          APPEND lv_line TO lt_temp_code.
        ENDIF.
      ENDLOOP.
      IF lt_temp_code IS NOT INITIAL.
        APPEND &apos;EXPORTING&apos; TO lt_code.
        APPEND LINES OF lt_temp_code TO lt_code.
      ENDIF.
      CLEAR: lt_temp_code.
      LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
        READ TABLE mt_constructor_parameters TRANSPORTING NO FIELDS WITH KEY name = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          CONCATENATE &lt;ls_parameter&gt;-name &apos;=&apos; &lt;ls_parameter&gt;-name INTO lv_line SEPARATED BY space.
          APPEND lv_line TO lt_temp_code.
        ENDIF.
      ENDLOOP.
      IF lt_temp_code IS NOT INITIAL.
        APPEND &apos;CHANGING&apos; TO lt_code.
        APPEND LINES OF lt_temp_code TO lt_code.
      ENDIF.
    ENDIF.
    APPEND &apos;.&apos; TO lt_code.
  ENDIF.
  APPEND &apos;mo_mocker = io_mocker.&apos; TO lt_code.
  APPEND &apos;ENDMETHOD.&apos; TO lt_code.

  LOOP AT mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WHERE is_class = abap_false.
    CLEAR: lv_has_changing_parameter, lv_has_exporting_parameter, lv_has_returning_parameter.

    lo_mocker_method = resolve_method( &lt;ls_method&gt; ).
    IF mv_is_interface_mock = abap_false.&quot;is method relevant for generation?
      lv_generate_method = abap_false.
      IF lo_mocker_method IS NOT INITIAL.
        lv_generate_method = lo_mocker_method-&gt;has_registered_call_pattern( ).
      ENDIF.
      IF lv_generate_method = abap_false.
        CONTINUE.
      ENDIF.
    ENDIF.

*   create method stub
    IF mv_is_interface_mock = abap_true.
      CONCATENATE mv_interface &apos;~&apos; &lt;ls_method&gt;-name INTO lv_line.
    ELSE.
      lv_line = &lt;ls_method&gt;-name.
    ENDIF.

    CONCATENATE &apos;METHOD&apos; lv_line &apos;.&apos; INTO lv_line SEPARATED BY space.
    APPEND lv_line TO lt_code.

    APPEND &apos;DATA: lr_return TYPE REF TO DATA.&apos; TO lt_code.
    APPEND &apos;DATA: lv_exception TYPE seoclsname.&apos; TO lt_code.
    APPEND &apos;DATA: lo_mocker_method TYPE REF TO ZIF_MOCKA_MOCKER_METHOD.&apos; TO lt_code.
    APPEND &apos;FIELD-SYMBOLS: &lt;lv_return&gt; TYPE any.&apos; TO lt_code.
    IF &lt;ls_method&gt;-alias_for IS NOT INITIAL.
      CONCATENATE &apos;lo_mocker_method ?= mo_mocker-&gt;method( &apos;&apos;&apos; &lt;ls_method&gt;-alias_for &apos;&apos;&apos; ).&apos; INTO lv_line.
    ELSE.
      CONCATENATE &apos;lo_mocker_method ?= mo_mocker-&gt;method( &apos;&apos;&apos; &lt;ls_method&gt;-name &apos;&apos;&apos; ).&apos; INTO lv_line.
    ENDIF.
    APPEND lv_line TO lt_code.
    APPEND &apos;lo_mocker_method-&gt;increase_times_called( ).&apos; TO lt_code.

    APPEND &apos;DATA ls_importing TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO lt_code.
    APPEND &apos;DATA ls_changing_in TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO lt_code.
    APPEND &apos;DATA ls_exporting TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO lt_code.
    APPEND &apos;DATA ls_changing_out TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO lt_code.
    APPEND &apos;DATA lt_importing TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR.&apos; TO lt_code.
    APPEND &apos;DATA lt_changing_in TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR.&apos; TO lt_code.
    APPEND &apos;DATA lt_exporting TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR.&apos; TO lt_code.
    APPEND &apos;DATA lt_changing_out TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR.&apos; TO lt_code.
    APPEND &apos;FIELD-SYMBOLS &lt;ls_exporting&gt; TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO lt_code.
    APPEND &apos;FIELD-SYMBOLS &lt;lv_exporting_out&gt; TYPE any.&apos; TO lt_code.
    APPEND &apos;FIELD-SYMBOLS &lt;lv_exporting_from_mocker&gt; TYPE any.&apos; TO lt_code.

*   map IMPORTING parameters
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;I&apos;.
      APPEND lv_line TO lt_code.
      IF &lt;ls_parameter&gt;-is_optional = abap_true.
        CONCATENATE &apos;IF&apos; &lt;ls_parameter&gt;-name &apos;IS SUPPLIED.&apos; INTO lv_line SEPARATED BY space.
      ENDIF.
      APPEND lv_line TO lt_code.
      CONCATENATE &apos;ls_importing-parameter = &apos;&apos;&apos; &lt;ls_parameter&gt;-name &apos;&apos;&apos;.&apos; INTO lv_line.
      APPEND lv_line TO lt_code.
      CONCATENATE &apos;GET REFERENCE OF&apos; &lt;ls_parameter&gt;-name &apos;into ls_importing-value.&apos; INTO lv_line SEPARATED BY space.
      APPEND lv_line TO lt_code.
      APPEND &apos;APPEND ls_importing TO lt_importing.&apos; TO lt_code.
      IF &lt;ls_parameter&gt;-is_optional = abap_true.
        APPEND &apos;ENDIF.&apos; TO lt_code.
      ENDIF.
    ENDLOOP.
*   map CHANGING parameters
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
      CONCATENATE &apos;ls_changing_in-parameter = &apos;&apos;&apos; &lt;ls_parameter&gt;-name &apos;&apos;&apos;.&apos; INTO lv_line.
      APPEND lv_line TO lt_code.
      IF &lt;ls_parameter&gt;-is_optional = abap_true.
        CONCATENATE &apos;IF&apos; &lt;ls_parameter&gt;-name &apos;IS SUPPLIED.&apos; INTO lv_line SEPARATED BY space.
      ENDIF.
      APPEND lv_line TO lt_code.
      CONCATENATE &apos;GET REFERENCE OF&apos; &lt;ls_parameter&gt;-name &apos;into ls_changing_in-value.&apos; INTO lv_line SEPARATED BY space.
      APPEND lv_line TO lt_code.
      APPEND &apos;APPEND ls_changing_in TO lt_changing_in.&apos; TO lt_code.
      IF &lt;ls_parameter&gt;-is_optional = abap_true.
        APPEND &apos;ENDIF.&apos; TO lt_code.
      ENDIF.
    ENDLOOP.

*   is there any exception registered?
    APPEND &apos;lv_exception = lo_mocker_method-&gt;raise( it_importing = lt_importing it_changing_in = lt_changing_in ).&apos; TO lt_code.

    ls_method_key-clsname = mv_interface.
    ls_method_key-cmpname = &lt;ls_method&gt;-name.
    CALL FUNCTION &apos;SEO_METHOD_SIGNATURE_GET&apos;
      EXPORTING
        mtdkey       = ls_method_key
      IMPORTING
        exceps       = lt_exceptions
      EXCEPTIONS
        not_existing = 1
        is_event     = 2
        is_type      = 3
        is_attribute = 4
        model_only   = 5
        OTHERS       = 6.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_message.
      RAISE EXCEPTION TYPE zcx_mocka
        EXPORTING
          textid       = zcx_mocka=&gt;zcx_mocka
          generic_text = lv_message.
    ELSE.
      READ TABLE lt_exceptions ASSIGNING &lt;ls_exception&gt; INDEX 1.
      IF sy-subrc = 0.
        lv_is_class_based_exception = me-&gt;is_exception_class( &lt;ls_exception&gt;-sconame ).
      ENDIF.
    ENDIF.
    IF lv_is_class_based_exception = abap_true.
      APPEND &apos;DATA lo_cx_exc TYPE REF TO cx_root.&apos; TO lt_code.
      APPEND &apos;IF lv_exception IS NOT INITIAL.&apos; TO lt_code.
      APPEND &apos;  TRANSLATE lv_exception TO UPPER CASE.&apos; TO lt_code.
      APPEND &apos;  CREATE OBJECT lo_cx_exc TYPE (lv_exception).&apos; TO lt_code.
      APPEND &apos;  RAISE EXCEPTION lo_cx_exc.&apos; TO lt_code.
      APPEND &apos;ENDIF.&apos; TO lt_code.
    ENDIF.

*   call mocker method to retrieve values
    READ TABLE &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WITH KEY parm_kind = &apos;E&apos;.
    IF sy-subrc = 0.
      lv_has_exporting_parameter = abap_true.
    ENDIF.

    READ TABLE &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WITH KEY parm_kind = &apos;C&apos;.
    IF sy-subrc = 0.
      lv_has_changing_parameter = abap_true.
    ENDIF.
    READ TABLE &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WITH KEY parm_kind = &apos;R&apos;.
    IF sy-subrc = 0.
      lv_has_returning_parameter = abap_true.
    ENDIF.

    IF lv_has_changing_parameter = abap_true OR lv_has_exporting_parameter = abap_true.
      APPEND &apos;CALL METHOD lo_mocker_method-&gt;export&apos; TO lt_code.
    ENDIF.

    IF lv_has_returning_parameter = abap_true.
      APPEND &apos;CALL METHOD lo_mocker_method-&gt;return&apos; TO lt_code.
    ENDIF.

    IF lv_has_changing_parameter = abap_true
      OR lv_has_exporting_parameter = abap_true
      OR lv_has_returning_parameter = abap_true.
      APPEND &apos;EXPORTING it_importing = lt_importing it_changing_in = lt_changing_in&apos; TO lt_code.
    ENDIF.

*   map RETURNING parameter, if any
    IF lv_has_returning_parameter = abap_true.
      APPEND &apos;RECEIVING&apos; TO lt_code.
      APPEND &apos;r_result = lr_return.&apos; TO lt_code.
      READ TABLE &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WITH KEY parm_kind = &apos;R&apos;.
      IF sy-subrc = 0.
        APPEND &apos;IF lr_return IS BOUND.&apos; TO lt_code.
        APPEND &apos;ASSIGN lr_return-&gt;* TO &lt;lv_return&gt;.&apos; TO lt_code.
        CONCATENATE &lt;ls_parameter&gt;-name &apos; = &lt;lv_return&gt;.&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_code.
        APPEND &apos;ENDIF.&apos; TO lt_code.
      ENDIF.
    ELSE.
*     map EXPORTING/CHANGING parameters, if any

      IF lv_has_changing_parameter = abap_true
        OR lv_has_exporting_parameter = abap_true.
        APPEND &apos;IMPORTING&apos; TO lt_code.
      ENDIF.


      IF lv_has_exporting_parameter = abap_true.
        APPEND &apos;et_exporting = lt_exporting&apos; TO lt_code.
      ENDIF.
      IF lv_has_changing_parameter = abap_true.
        APPEND &apos;et_changing_out = lt_changing_out&apos; TO lt_code.
      ENDIF.
      APPEND &apos;.&apos; TO lt_code.

      LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;E&apos;.
        CONCATENATE &apos;FREE: &apos; &lt;ls_parameter&gt;-name &apos;.&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_code.
        CONCATENATE &apos;GET REFERENCE OF&apos; &lt;ls_parameter&gt;-name &apos;into ls_exporting-value.&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_code.
        CONCATENATE &apos;READ TABLE lt_exporting ASSIGNING &lt;ls_exporting&gt; WITH KEY parameter = &apos;&apos;&apos; &lt;ls_parameter&gt;-name &apos;&apos;&apos;.&apos; INTO lv_line.
        APPEND lv_line TO lt_code.
        APPEND &apos;IF sy-subrc = 0.&apos; TO lt_code.
        APPEND &apos;ASSIGN ls_exporting-value-&gt;* TO &lt;lv_exporting_out&gt;.&apos; TO lt_code.
        APPEND &apos;ASSIGN &lt;ls_exporting&gt;-value-&gt;* TO &lt;lv_exporting_from_mocker&gt;.&apos; TO lt_code.
        APPEND &apos;&lt;lv_exporting_out&gt; = &lt;lv_exporting_from_mocker&gt;.&apos; TO lt_code.
        APPEND &apos;ENDIF.&apos; TO lt_code.
      ENDLOOP.

      LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
        IF &lt;ls_parameter&gt;-is_optional = abap_true.
          CONCATENATE &apos;IF&apos; &lt;ls_parameter&gt;-name &apos;IS SUPPLIED.&apos; INTO lv_line SEPARATED BY space.
        ENDIF.
        APPEND lv_line TO lt_code.
        CONCATENATE &apos;GET REFERENCE OF&apos; &lt;ls_parameter&gt;-name &apos;into ls_changing_out-value.&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_code.
        CONCATENATE &apos;READ TABLE lt_changing_out ASSIGNING &lt;ls_exporting&gt; WITH KEY parameter = &apos;&apos;&apos; &lt;ls_parameter&gt;-name &apos;&apos;&apos;.&apos; INTO lv_line.
        APPEND lv_line TO lt_code.
        APPEND &apos;IF sy-subrc = 0.&apos; TO lt_code.
        APPEND &apos;ASSIGN ls_changing_out-value-&gt;* TO &lt;lv_exporting_out&gt;.&apos; TO lt_code.
        APPEND &apos;ASSIGN &lt;ls_exporting&gt;-value-&gt;* TO &lt;lv_exporting_from_mocker&gt;.&apos; TO lt_code.
        APPEND &apos;&lt;lv_exporting_out&gt; = &lt;lv_exporting_from_mocker&gt;.&apos; TO lt_code.
        APPEND &apos;ENDIF.&apos; TO lt_code.
        IF &lt;ls_parameter&gt;-is_optional = abap_true.
          APPEND &apos;ENDIF.&apos; TO lt_code.
        ENDIF.
      ENDLOOP.

    ENDIF.
    APPEND &apos;ENDMETHOD.&apos; TO lt_code.
  ENDLOOP.
  APPEND &apos;ENDCLASS.&apos; TO lt_code.

  DATA: lv_subrc LIKE sy-subrc.

  CALL METHOD zcl_mocka_helper_mocker=&gt;generate_subroutine_pool
    EXPORTING
      it_code    = lt_code
    IMPORTING
      ev_message = lv_message
      ev_prog    = lv_prog
      ev_subrc   = lv_subrc.
  IF lv_subrc NE 0.
    raise_exception( lv_message ).
  ENDIF.

  CONCATENATE `\PROGRAM=` lv_prog `\CLASS=` lv_classname INTO mv_generated_class.

  ls_constructor_parameter-name = &apos;IO_MOCKER&apos;.
  ls_constructor_parameter-kind = &apos;E&apos;.
  GET REFERENCE OF me INTO ls_constructor_parameter-value.
  INSERT ls_constructor_parameter INTO TABLE lt_constructor_parameters.
  INSERT LINES OF mt_constructor_parameters INTO TABLE lt_constructor_parameters.
  CREATE OBJECT ro_mockup
    TYPE
      (mv_generated_class)
    PARAMETER-TABLE
      lt_constructor_parameters.

  DATA ls_generated_class TYPE ty_s_generated_class.
  ls_generated_class-name = mv_interface.
  ls_generated_class-technical_name = mv_generated_class.
  APPEND ls_generated_class TO mt_generated_classes.
ENDMETHOD.                    &quot;ZIF_MOCKA_MOCKER~generate_mockup</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~GET_INTERFACE">
   <source>METHOD ZIF_MOCKA_MOCKER~get_interface.
  rv_interface = mv_interface.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~HAS_ANY_METHOD_BEEN_CALLED">
   <source>METHOD ZIF_MOCKA_MOCKER~has_any_method_been_called.
  FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mt_method_mocks.
  LOOP AT mt_method_mocks ASSIGNING &lt;ls_method&gt;.
    rv_has_been_called = &lt;ls_method&gt;-method_mock-&gt;has_method_been_called( ).
    IF rv_has_been_called = abap_true.
      RETURN.
    ENDIF.
  ENDLOOP.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~HAS_METHOD_BEEN_CALLED">
   <source>METHOD ZIF_MOCKA_MOCKER~has_method_been_called.
  DATA lv_call_count TYPE i.
  DATA lv_method LIKE iv_method_name.
  lv_method = iv_method_name.
  TRANSLATE lv_method TO UPPER CASE.

  CALL METHOD me-&gt;ZIF_MOCKA_MOCKER~method_call_count
    EXPORTING
      iv_method_name = lv_method
    RECEIVING
      rv_call_count  = lv_call_count.
  IF lv_call_count &gt; 0.
    rv_has_been_called = abap_true.
  ELSE.
    rv_has_been_called = abap_false.
  ENDIF.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~METHOD">
   <source>METHOD ZIF_MOCKA_MOCKER~method.
  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lv_method_name LIKE iv_method_name.

  lv_method_name = iv_method_name.
  TRANSLATE lv_method_name TO UPPER CASE.

  DATA ls_method TYPE ty_s_methods.
  READ TABLE mt_method_mocks INTO ls_method WITH KEY method_name = lv_method_name.
  IF sy-subrc = 0.
    ro_method = ls_method-method_mocker.
    RETURN.
  ENDIF.

  READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = lv_method_name.
  IF sy-subrc NE 0.
    READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY alias_for = lv_method_name.
  ENDIF.

  IF &lt;ls_method&gt; IS NOT ASSIGNED.
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid    = ZCX_MOCKA=&gt;no_such_method
        interface = mv_interface
        method    = lv_method_name.
  ENDIF.

  CREATE OBJECT ro_method TYPE ZCL_MOCKA_MOCKER_method
    EXPORTING
      iv_method_name = lv_method_name
      io_mocker      = me.

  ls_method-method_mocker = ro_method.
  ls_method-name = lv_method_name.
  APPEND ls_method TO mt_method_mocks.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~METHOD_CALL_COUNT">
   <source>METHOD ZIF_MOCKA_MOCKER~method_call_count.
  FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mt_method_mocks.
  DATA lv_method_name LIKE iv_method_name.
  lv_method_name = iv_method_name.
  TRANSLATE lv_method_name TO UPPER CASE.

  READ TABLE mt_method_mocks ASSIGNING &lt;ls_method&gt; WITH KEY method_name = lv_method_name.
  IF sy-subrc = 0.
    rv_call_count = &lt;ls_method&gt;-method_mock-&gt;times_called( ).
  ENDIF.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~MOCK">
   <source>METHOD ZIF_MOCKA_MOCKER~mock.
  DATA lo_mocker TYPE REF TO ZCL_MOCKA_MOCKER.
  DATA lo_typedescr TYPE REF TO cl_abap_typedescr.
  DATA lo_cx_root TYPE REF TO cx_root.
  DATA lv_message TYPE string.
  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lv_interface LIKE iv_interface.

  check_unit_test_execution( ).

  lv_interface = iv_interface.
  TRANSLATE lv_interface TO UPPER CASE.

  CREATE OBJECT lo_mocker.

  CALL METHOD cl_abap_intfdescr=&gt;describe_by_name
    EXPORTING
      p_name         = lv_interface
    RECEIVING
      p_descr_ref    = lo_typedescr
    EXCEPTIONS
      type_not_found = 1
      OTHERS         = 2.
  IF sy-subrc NE 0.
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid    = ZCX_MOCKA=&gt;no_such_interface
        interface = iv_interface.
  ENDIF.

  IF lo_typedescr-&gt;type_kind = cl_abap_typedescr=&gt;typekind_class.
    lo_mocker-&gt;mv_is_interface_mock = abap_false.
  ELSE.
    lo_mocker-&gt;mv_is_interface_mock = abap_true.
  ENDIF.

  TRY.
      ro_mocker = lo_mocker.
      lo_mocker-&gt;mo_objectdescr ?= lo_typedescr.
      lo_mocker-&gt;mv_interface = lv_interface.
      LOOP AT lo_mocker-&gt;mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt;.
        lo_mocker-&gt;resolve_method( &lt;ls_method&gt; ).
      ENDLOOP.

      DATA ls_generated_class TYPE ty_s_generated_class.
      READ TABLE mt_generated_classes INTO ls_generated_class WITH KEY name = lv_interface.
      IF sy-subrc = 0.
        lo_mocker-&gt;mv_generated_class = ls_generated_class-technical_name.
      ENDIF.
    CATCH cx_root INTO lo_cx_root.
      lv_message = lo_cx_root-&gt;get_text( ).
      RAISE EXCEPTION TYPE ZCX_MOCKA
        EXPORTING
          textid       = ZCX_MOCKA=&gt;ZCX_MOCKA
          generic_text = lv_message.
  ENDTRY.

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~PASS_TO_SUPER_CONSTRUCTOR">
   <source>METHOD ZIF_MOCKA_MOCKER~pass_to_super_constructor.
  DATA ls_param LIKE LINE OF mt_constructor_parameters.
  FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mo_objectdescr-&gt;methods.
  FIELD-SYMBOLS &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lr_value TYPE REF TO data.
  CLEAR: mt_constructor_parameters.

  READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = &apos;CONSTRUCTOR&apos;.
  IF sy-subrc = 0.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;I&apos; OR parm_kind = &apos;C&apos;.
      CLEAR: lr_value.
      CASE sy-tabix.
        WHEN 1.
          IF i_p1 IS SUPPLIED.
            GET REFERENCE OF i_p1 INTO lr_value.
          ENDIF.
        WHEN 2.
          IF i_p2 IS SUPPLIED.
            GET REFERENCE OF i_p2 INTO lr_value.
          ENDIF.
        WHEN 3.
          IF i_p3 IS SUPPLIED.
            GET REFERENCE OF i_p3 INTO lr_value.
          ENDIF.
        WHEN 4.
          IF i_p4 IS SUPPLIED.
            GET REFERENCE OF i_p4 INTO lr_value.
          ENDIF.
        WHEN 5.
          IF i_p5 IS SUPPLIED.
            GET REFERENCE OF i_p5 INTO lr_value.
          ENDIF.
        WHEN 6.
          IF i_p6 IS SUPPLIED.
            GET REFERENCE OF i_p6 INTO lr_value.
          ENDIF.
        WHEN 7.
          IF i_p7 IS SUPPLIED.
            GET REFERENCE OF i_p7 INTO lr_value.
          ENDIF.
        WHEN 8.
          IF i_p8 IS SUPPLIED.
            GET REFERENCE OF i_p8 INTO lr_value.
          ENDIF.
      ENDCASE.

      IF lr_value IS BOUND.
        ls_param-value = copy_value( lr_value ).
        ls_param-name = &lt;ls_parameter&gt;-name.

        IF &lt;ls_parameter&gt;-parm_kind = &apos;I&apos;.
          ls_param-kind = &apos;E&apos;.
        ENDIF.
        IF &lt;ls_parameter&gt;-parm_kind = &apos;E&apos;.
          ls_param-kind = &apos;I&apos;.
        ENDIF.
        IF &lt;ls_parameter&gt;-parm_kind = &apos;C&apos;.
          ls_param-kind = &apos;C&apos;.
        ENDIF.
        INSERT ls_param INTO TABLE mt_constructor_parameters.
      ENDIF.
    ENDLOOP.
  ELSE.
*     @todo: proper exception handling
  ENDIF.
  ro_mocker = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="CHECK_UNIT_TEST_EXECUTION" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD check_unit_test_execution.
  DATA lv_is_unit_test_allowed TYPE abap_bool.
  lv_is_unit_test_allowed = cl_aunit_permission_control=&gt;is_test_enabled_client( ).
  IF lv_is_unit_test_allowed = abap_false.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid = zcx_mocka=&gt;unit_test_exec_not_allowed.
  ENDIF.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="COPY_VALUE" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="COPY_VALUE" SCONAME="IR_REF" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="COPY_VALUE" SCONAME="RR_REF" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD COPY_VALUE.
  FIELD-SYMBOLS &lt;lv_in&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_out&gt; TYPE any.

  ASSIGN ir_ref-&gt;* TO &lt;lv_in&gt;.
  CREATE DATA rr_ref LIKE &lt;lv_in&gt;.
  ASSIGN rr_ref-&gt;* TO &lt;lv_out&gt;.
  &lt;lv_out&gt; = &lt;lv_in&gt;.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="IS_EXCEPTION_CLASS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="IS_EXCEPTION_CLASS" SCONAME="IV_CLASSNAME" VERSION="1" LANGU="E" DESCRIPT="Object Type Name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="IS_EXCEPTION_CLASS" SCONAME="RV_IS_EXCEPTION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>METHOD is_exception_class.
  DATA ls_clskey TYPE seoclskey.
  ls_clskey-clsname = iv_classname.
  DATA ls_class TYPE seoc_class_r.
  CALL FUNCTION &apos;SEO_CLASS_READ&apos;
    EXPORTING
      clskey = ls_clskey
    IMPORTING
      class  = ls_class.
  IF sy-subrc = 0.
    IF ls_class-category = 40.
      rv_is_exception = abap_true.
    ENDIF.
  ENDIF.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RAISE_EXCEPTION" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RAISE_EXCEPTION" SCONAME="IV_MESSAGE" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <source>METHOD raise_exception.
  RAISE EXCEPTION TYPE ZCX_MOCKA
    EXPORTING
      textid       = ZCX_MOCKA=&gt;ZCX_MOCKA
      generic_text = iv_message.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RESOLVE_METHOD" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RESOLVE_METHOD" SCONAME="IS_METHOD" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_METHDESCR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RESOLVE_METHOD" SCONAME="RO_METHOD_MOCK" VERSION="1" LANGU="D" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
   <source>METHOD resolve_method.
  IF is_method-alias_for IS NOT INITIAL.
    ro_method_mock = me-&gt;ZIF_MOCKA_MOCKER~method( is_method-alias_for ).
  ELSE.
    ro_method_mock = me-&gt;ZIF_MOCKA_MOCKER~method( is_method-name ).
  ENDIF.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_MOCKA_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="implements a single mock-method" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <friends CLSNAME="ZCL_MOCKA_MOCKER_METHOD" REFCLSNAME="ZCL_MOCKA_MOCKER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <implementing CLSNAME="ZCL_MOCKA_MOCKER_METHOD" REFCLSNAME="ZIF_MOCKA_MOCKER_METHOD" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <textPool>
   <language SPRAS="E"/>
  </textPool>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER_METHOD" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER_METHOD" TYPEGROUP="SEOC" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <forwardDeclaration>SEOC</forwardDeclaration>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MO_MOCKER" VERSION="1" LANGU="D" DESCRIPT="Beschreibt einen Mock-Erzeuger" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_MOCKA_MOCKER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MS_CURRENT_METHOD_CALL_PATTERN" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_METHOD_CALL_PATTERN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MT_METHOD_CALL_PATTERNS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="90 " TYPESRC_LENG="87 " TYPESRC="mt_method_call_patterns TYPE TABLE OF ZIF_MOCKA_MOCKER_method=&gt;ty_s_method_call_pattern"/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MV_METHOD_NAME" VERSION="1" LANGU="D" DESCRIPT="Vollständiger Komponentenname" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCPDNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MV_TIMES_CALLED" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~CHANGES">
   <source>METHOD ZIF_MOCKA_MOCKER_method~changes.

  DATA lv_parameter_count TYPE i.
  DATA lv_actual_parameter_count TYPE i.
  DATA lr_ref TYPE REF TO data.
  FIELD-SYMBOLS &lt;lv_in&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_to&gt; TYPE any.
*  IF i_p1 IS SUPPLIED.
  ADD 1 TO lv_parameter_count.
*  ENDIF.
  IF i_p2 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.



  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid    = ZCX_MOCKA=&gt;no_such_method
        interface = mo_mocker-&gt;mv_interface
        method    = mv_method_name.
  ENDIF.
* count &amp; verify importing parameters
  LOOP AT &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WHERE parm_kind = &apos;E&apos;.
    ADD 1 TO lv_actual_parameter_count.
  ENDLOOP.
  IF lv_parameter_count &gt; lv_actual_parameter_count.
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid = ZCX_MOCKA=&gt;invalid_parameter_count.
  ENDIF.

* map importing parameters to current method call pattern
  DATA ls_changing_out LIKE LINE OF ms_current_method_call_pattern-importing.
  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.

  FREE: ms_current_method_call_pattern-changing_out.
  READ TABLE &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WITH KEY parm_kind = &apos;C&apos;.
  IF sy-subrc NE 0.
    DATA lv_interface TYPE abap_abstypename.
    lv_interface =  mo_mocker-&gt;ZIF_MOCKA_MOCKER~get_interface( ).
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid    = ZCX_MOCKA=&gt;no_changing_parameters
        interface = lv_interface
        method    = mv_method_name.
  ENDIF.
  LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
    ADD 1 TO lv_index.
    CASE lv_index.
      WHEN 1.
        GET REFERENCE OF i_p1 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 2.
        GET REFERENCE OF i_p2 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 3.
        GET REFERENCE OF i_p3 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 4.
        GET REFERENCE OF i_p4 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 5.
        GET REFERENCE OF i_p5 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 6.
        GET REFERENCE OF i_p6 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 7.
        GET REFERENCE OF i_p7 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 8.
        GET REFERENCE OF i_p8 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
    ENDCASE.
    ls_changing_out-parameter = &lt;ls_parameter&gt;-name.
    APPEND ls_changing_out TO ms_current_method_call_pattern-changing_out.
  ENDLOOP.

  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~EXPORT">
   <source>METHOD ZIF_MOCKA_MOCKER_method~export.
  CALL METHOD me-&gt;resolve_method_output
    EXPORTING
      it_importing    = it_importing
      it_changing_in  = it_changing_in
      iv_increase_call_counter = abap_true
    IMPORTING
      et_exporting    = et_exporting
      et_changing_out = et_changing_out.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~EXPORTS">
   <source>METHOD ZIF_MOCKA_MOCKER_method~exports.

  DATA lv_parameter_count TYPE i.
  DATA lv_actual_parameter_count TYPE i.
  DATA lr_ref TYPE REF TO data.
  FIELD-SYMBOLS &lt;lv_in&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_to&gt; TYPE any.
*  IF i_p1 IS SUPPLIED.
  ADD 1 TO lv_parameter_count.
*  ENDIF.
  IF i_p2 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.



  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid    = ZCX_MOCKA=&gt;no_such_method
        interface = mo_mocker-&gt;mv_interface
        method    = mv_method_name.
  ENDIF.
* count &amp; verify importing parameters
  LOOP AT &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WHERE parm_kind = &apos;E&apos;.
    ADD 1 TO lv_actual_parameter_count.
  ENDLOOP.
  IF lv_parameter_count &gt; lv_actual_parameter_count.
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid = ZCX_MOCKA=&gt;invalid_parameter_count.
  ENDIF.

* map importing parameters to current method call pattern
  DATA ls_exporting LIKE LINE OF ms_current_method_call_pattern-importing.
  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.

  FREE: ms_current_method_call_pattern-exporting.
  READ TABLE &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WITH KEY parm_kind = &apos;E&apos;.
  IF sy-subrc NE 0.
    DATA lv_interface TYPE abap_abstypename.
    lv_interface =  mo_mocker-&gt;ZIF_MOCKA_MOCKER~get_interface( ).
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid    = ZCX_MOCKA=&gt;no_exporting_parameters
        interface = lv_interface
        method    = mv_method_name.
  ENDIF.
  LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;E&apos;.
    ADD 1 TO lv_index.
    CASE lv_index.
      WHEN 1.
        GET REFERENCE OF i_p1 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 2.
        GET REFERENCE OF i_p2 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 3.
        GET REFERENCE OF i_p3 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 4.
        GET REFERENCE OF i_p4 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 5.
        GET REFERENCE OF i_p5 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 6.
        GET REFERENCE OF i_p6 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 7.
        GET REFERENCE OF i_p7 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 8.
        GET REFERENCE OF i_p8 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
    ENDCASE.
    ls_exporting-parameter = &lt;ls_parameter&gt;-name.
    APPEND ls_exporting TO ms_current_method_call_pattern-exporting.
  ENDLOOP.

  finalize_current_method_sign( ).
  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~FINALIZE_CURRENT_METHOD_SIGN">
   <source>METHOD ZIF_MOCKA_MOCKER_method~finalize_current_method_sign.
  ro_mocker = finalize_current_method_sign( ).
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~GENERATE_MOCKUP">
   <source>METHOD ZIF_MOCKA_MOCKER_method~generate_mockup.
  ro_mockup = mo_mocker-&gt;ZIF_MOCKA_MOCKER~generate_mockup( ).
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~GET_ALL_RAISES_BY_NAME">
   <source>METHOD ZIF_MOCKA_MOCKER_method~get_all_raises_by_name.
  FIELD-SYMBOLS &lt;ls_pattern&gt; LIKE LINE OF mt_method_call_patterns.
  LOOP AT mt_method_call_patterns ASSIGNING &lt;ls_pattern&gt; WHERE raises_by_name IS NOT INITIAL.
    APPEND &lt;ls_pattern&gt;-raises_by_name TO rt_raises.
  ENDLOOP.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~HAS_METHOD_BEEN_CALLED">
   <source>METHOD ZIF_MOCKA_MOCKER_method~has_method_been_called.
  DATA lv_call_count TYPE i.
  CALL METHOD me-&gt;ZIF_MOCKA_MOCKER_method~times_called
    RECEIVING
      rv_times = lv_call_count.
  IF lv_call_count &gt; 0.
    rv_has_been_called = abap_true.
  ELSE.
    rv_has_been_called = abap_false.
  ENDIF.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~HAS_REGISTERED_CALL_PATTERN">
   <source>METHOD ZIF_MOCKA_MOCKER_method~has_registered_call_pattern.
  IF mt_method_call_patterns IS NOT INITIAL.
    rv_has_pattern_registered = abap_true.
  ENDIF.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~INCREASE_TIMES_CALLED">
   <source>METHOD ZIF_MOCKA_MOCKER_method~increase_times_called.
  ADD iv_increment TO mv_times_called.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RAISE">
   <source>METHOD ZIF_MOCKA_MOCKER_method~raise.
  DATA lo_cx_root TYPE REF TO cx_root.
  CALL METHOD me-&gt;resolve_method_output
    EXPORTING
      it_importing   = it_importing
      it_changing_in = it_changing_in
    IMPORTING
      ev_exception   = rv_exception
      eo_cx_root     = lo_cx_root.
  IF lo_cx_root IS NOT INITIAL.
    RAISE EXCEPTION lo_cx_root.
  ENDIF.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RAISES">
   <source>METHOD ZIF_MOCKA_MOCKER_method~raises.
  CLEAR: ms_current_method_call_pattern-raises_by_name.
  ms_current_method_call_pattern-raises = io_cx_root.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RAISES_BY_NAME">
   <source>METHOD ZIF_MOCKA_MOCKER_method~raises_by_name.
  DATA: ls_class_descr TYPE vseoclass,
        ls_seoclskey TYPE seoclskey,
        lv_exception TYPE seoclsname.
  DATA lv_interface TYPE abap_abstypename.
  lv_exception = iv_exception.
  TRANSLATE lv_exception TO UPPER CASE.

  ls_seoclskey-clsname = lv_exception.
  CALL FUNCTION &apos;SEO_CLASS_READ&apos;
    EXPORTING
      clskey = ls_seoclskey
    IMPORTING
      class  = ls_class_descr.
  IF ls_class_descr IS INITIAL.
    lv_interface = mo_mocker-&gt;ZIF_MOCKA_MOCKER~get_interface( ).
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid    = ZCX_MOCKA=&gt;no_such_exception
        interface = lv_interface
        exception = lv_exception
        method    = mv_method_name.
  ENDIF.
  IF ls_class_descr-category NE seoc_category_exception.
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid    = ZCX_MOCKA=&gt;invalid_exception
        exception = lv_exception.
  ENDIF.
  IF ls_class_descr-clsabstrct = abap_true.
    RAISE EXCEPTION TYPE ZCX_MOCKA
      EXPORTING
        textid    = ZCX_MOCKA=&gt;abstract_exception
        exception = lv_exception.
  ENDIF.
  FREE: ms_current_method_call_pattern-raises.
  ms_current_method_call_pattern-raises_by_name = lv_exception.
  APPEND ms_current_method_call_pattern TO mt_method_call_patterns.

  FREE: ms_current_method_call_pattern.
  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RETURN">
   <source>METHOD ZIF_MOCKA_MOCKER_method~return.
  CALL METHOD me-&gt;resolve_method_output
    EXPORTING
      it_importing   = it_importing
      it_changing_in = it_changing_in
      iv_increase_call_counter = abap_true
    IMPORTING
*     et_exporting   =
      er_result      = r_result
*     ev_exception   =
    .

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RETURNS">
   <source>METHOD ZIF_MOCKA_MOCKER_method~returns.
  TRY.
      me-&gt;ZIF_MOCKA_MOCKER_method~exports( i_return ).
    CATCH ZCX_MOCKA.
      DATA lr_ref TYPE REF TO data.
      FIELD-SYMBOLS: &lt;lv_in&gt; TYPE any, &lt;lv_to&gt; TYPE any.
      GET REFERENCE OF i_return INTO lr_ref.

      ASSIGN lr_ref-&gt;* TO &lt;lv_in&gt;.
      CREATE DATA ms_current_method_call_pattern-returning LIKE &lt;lv_in&gt;.
      ASSIGN ms_current_method_call_pattern-returning-&gt;* TO &lt;lv_to&gt;.
      &lt;lv_to&gt; = &lt;lv_in&gt;.
      APPEND ms_current_method_call_pattern TO mt_method_call_patterns.

      FREE: ms_current_method_call_pattern.
  ENDTRY.

  finalize_current_method_sign( ).
  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~TIMES_CALLED">
   <source>METHOD ZIF_MOCKA_MOCKER_method~times_called.
  rv_times = mv_times_called.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~WITH">
   <source>METHOD ZIF_MOCKA_MOCKER_method~with.
  finalize_current_method_sign( ).

  DATA lt_params TYPE abap_parmbind_tab.
  DATA ls_param TYPE abap_parmbind.
  DATA lv_iv_is_importing TYPE abap_bool VALUE abap_true.
  FIELD-SYMBOLS &lt;lv_val&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_val2&gt; TYPE any.

  ls_param-kind = &apos;E&apos;.
  IF i_p1 IS SUPPLIED.
    GET REFERENCE OF i_p1 INTO ls_param-value.
    ls_param-name = &apos;I_P1&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p2 IS SUPPLIED.
    GET REFERENCE OF i_p2 INTO ls_param-value.
    ls_param-name = &apos;I_P2&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    GET REFERENCE OF i_p3 INTO ls_param-value.
    ls_param-name = &apos;I_P3&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    GET REFERENCE OF i_p4 INTO ls_param-value.
    ls_param-name = &apos;I_P4&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    GET REFERENCE OF i_p5 INTO ls_param-value.
    ls_param-name = &apos;I_P5&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    GET REFERENCE OF i_p6 INTO ls_param-value.
    ls_param-name = &apos;I_P6&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    GET REFERENCE OF i_p7 INTO ls_param-value.
    ls_param-name = &apos;I_P7&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    GET REFERENCE OF i_p8 INTO ls_param-value.
    ls_param-name = &apos;I_P8&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.

  ls_param-name = &apos;IV_IS_IMPORTING&apos;.
  GET REFERENCE OF lv_iv_is_importing INTO ls_param-value.
  INSERT ls_param INTO TABLE lt_params.

  CALL METHOD (&apos;WITH_INTERNAL&apos;)
      PARAMETER-TABLE
      lt_params.

  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~WITH_CHANGING">
   <source>METHOD ZIF_MOCKA_MOCKER_method~with_changing.
  DATA lt_params TYPE abap_parmbind_tab.
  DATA ls_param TYPE abap_parmbind.
  DATA lv_iv_is_importing TYPE abap_bool.
  FIELD-SYMBOLS &lt;lv_val&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_val2&gt; TYPE any.

  ls_param-kind = &apos;E&apos;.
  IF i_p1 IS SUPPLIED.
    GET REFERENCE OF i_p1 INTO ls_param-value.
    ls_param-name = &apos;I_P1&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p2 IS SUPPLIED.
    GET REFERENCE OF i_p2 INTO ls_param-value.
    ls_param-name = &apos;I_P2&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    GET REFERENCE OF i_p3 INTO ls_param-value.
    ls_param-name = &apos;I_P3&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    GET REFERENCE OF i_p4 INTO ls_param-value.
    ls_param-name = &apos;I_P4&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    GET REFERENCE OF i_p5 INTO ls_param-value.
    ls_param-name = &apos;I_P5&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    GET REFERENCE OF i_p6 INTO ls_param-value.
    ls_param-name = &apos;I_P6&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    GET REFERENCE OF i_p7 INTO ls_param-value.
    ls_param-name = &apos;I_P7&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    GET REFERENCE OF i_p8 INTO ls_param-value.
    ls_param-name = &apos;I_P8&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.

  ls_param-name = &apos;IV_IS_IMPORTING&apos;.
  GET REFERENCE OF lv_iv_is_importing INTO ls_param-value.
  INSERT ls_param INTO TABLE lt_params.

  CALL METHOD (&apos;WITH_INTERNAL&apos;)
      PARAMETER-TABLE
      lt_params.

  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="CONSTRUCTOR" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="D" DESCRIPT="Vollständiger Komponentenname" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="CONSTRUCTOR" SCONAME="IO_MOCKER" VERSION="1" LANGU="D" DESCRIPT="implementiert eine Erzeuger von Attrappen" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_MOCKA_MOCKER"/>
   <source>METHOD constructor.
  mv_method_name = iv_method_name.
  mo_mocker = io_mocker.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="COPY_VALUE" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="COPY_VALUE" SCONAME="IR_REF" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="COPY_VALUE" SCONAME="RR_REF" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD copy_value.
  FIELD-SYMBOLS &lt;lv_in&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_out&gt; TYPE any.

  ASSIGN ir_ref-&gt;* TO &lt;lv_in&gt;.
  CREATE DATA rr_ref LIKE &lt;lv_in&gt;.
  ASSIGN rr_ref-&gt;* TO &lt;lv_out&gt;.
  &lt;lv_out&gt; = &lt;lv_in&gt;.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="FINALIZE_CURRENT_METHOD_SIGN" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="FINALIZE_CURRENT_METHOD_SIGN" SCONAME="RO_MOCKER" VERSION="1" LANGU="D" DESCRIPT="Beschreibt einen Mockup-Erzeuger" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
   <source>METHOD finalize_current_method_sign.
  ro_mocker = mo_mocker.
  CHECK ms_current_method_call_pattern IS NOT INITIAL.
  APPEND ms_current_method_call_pattern TO mt_method_call_patterns.
  FREE: ms_current_method_call_pattern.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" VERSION="1" LANGU="D" DESCRIPT="liefert EXPORTING-Parameter auf Basis des Aufrufes" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="IT_IMPORTING" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="IV_INCREASE_CALL_COUNTER" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="ET_CHANGING_OUT" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="ET_EXPORTING" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="ER_RESULT" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="EV_EXCEPTION" VERSION="1" LANGU="D" DESCRIPT="Objekttypname" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="EO_CX_ROOT" VERSION="1" LANGU="D" DESCRIPT="Abstrakte Oberklasse aller globalen Exceptions" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="CX_ROOT"/>
   <source>METHOD resolve_method_output.
  CLEAR: et_exporting,
          er_result,
          ev_exception,
          et_changing_out,
          eo_cx_root.

  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.
  FIELD-SYMBOLS &lt;ls_method_call_pattern&gt; TYPE ZIF_MOCKA_MOCKER_method=&gt;ty_s_method_call_pattern.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE mo_mocker-&gt;mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    READ TABLE mo_mocker-&gt;mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY alias_for = mv_method_name.
  ENDIF.
  CHECK &lt;ls_method&gt; IS ASSIGNED.

  DATA ls_importing LIKE LINE OF ms_current_method_call_pattern-importing.
  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.
  FIELD-SYMBOLS &lt;lv_val&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_val_importing&gt; TYPE any.
  DATA lv_equals TYPE abap_bool.
  FIELD-SYMBOLS &lt;ls_importing&gt; LIKE LINE OF it_importing.

  LOOP AT mt_method_call_patterns ASSIGNING &lt;ls_method_call_pattern&gt;.
    CLEAR: lv_index.
    lv_equals = abap_true.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;I&apos;.
*     compare IMPORTING parameters
      READ TABLE it_importing ASSIGNING &lt;ls_importing&gt; WITH KEY parameter = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        READ TABLE &lt;ls_method_call_pattern&gt;-importing INTO ls_importing WITH KEY parameter = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          ASSIGN ls_importing-value-&gt;* TO &lt;lv_val&gt;.
          ASSIGN &lt;ls_importing&gt;-value-&gt;* TO &lt;lv_val_importing&gt;.
          lv_equals = ZCL_MOCKA_VALUE_COMPARISON=&gt;assert_equals( act = &lt;lv_val_importing&gt; exp = &lt;lv_val&gt; ).
        ELSE.
          IF &lt;ls_method_call_pattern&gt;-importing IS NOT INITIAL.
            lv_equals = abap_false.
          ENDIF.
        ENDIF.
      ENDIF.
      IF lv_equals = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF lv_equals = abap_false.
      CONTINUE.
    ENDIF.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
*     compare CHANGING parameters
      READ TABLE it_changing_in ASSIGNING &lt;ls_importing&gt; WITH KEY parameter = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        READ TABLE &lt;ls_method_call_pattern&gt;-changing_in INTO ls_importing WITH KEY parameter = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          ASSIGN ls_importing-value-&gt;* TO &lt;lv_val&gt;.
          ASSIGN &lt;ls_importing&gt;-value-&gt;* TO &lt;lv_val_importing&gt;.
          lv_equals = ZCL_MOCKA_VALUE_COMPARISON=&gt;assert_equals( act = &lt;lv_val_importing&gt; exp = &lt;lv_val&gt; ).
        ELSE.
          IF &lt;ls_method_call_pattern&gt;-changing_in IS NOT INITIAL.
            lv_equals = abap_false.
          ENDIF.
        ENDIF.
      ENDIF.
      IF lv_equals = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF lv_equals = abap_false.
      CONTINUE.
    ELSE.
      er_result = &lt;ls_method_call_pattern&gt;-returning.
      ev_exception = &lt;ls_method_call_pattern&gt;-raises_by_name.
      eo_cx_root = &lt;ls_method_call_pattern&gt;-raises.
      et_exporting = &lt;ls_method_call_pattern&gt;-exporting.
      et_changing_out = &lt;ls_method_call_pattern&gt;-changing_out.
      IF &lt;ls_method_call_pattern&gt;-times_resolved &gt; 0.
        CONTINUE.&quot;search for another pattern that might fit
      ELSE.
        EXIT.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF &lt;ls_method_call_pattern&gt; IS ASSIGNED AND ( iv_increase_call_counter = abap_true OR ev_exception IS NOT INITIAL OR eo_cx_root IS NOT INITIAL ).
    ADD 1 TO &lt;ls_method_call_pattern&gt;-times_resolved.
  ENDIF.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" VERSION="1" LANGU="D" DESCRIPT="registriert Aufrufparameter - IMPORTING" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P1" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P2" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P3" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P4" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P5" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P6" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P7" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P8" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="IV_IS_IMPORTING" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="RO_SELF" VERSION="1" LANGU="D" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="10 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
   <source>METHOD with_internal.
  DATA lv_param_kind TYPE c.
  IF iv_is_importing = abap_true.
    lv_param_kind = &apos;I&apos;.
  ELSE.
    lv_param_kind = &apos;C&apos;.
  ENDIF.

  DATA lv_parameter_count TYPE i.
  DATA lv_actual_parameter_count TYPE i.
  DATA lr_ref TYPE REF TO data.

  IF i_p1 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p2 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.



  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY alias_for = mv_method_name.
    IF sy-subrc NE 0.
      RAISE EXCEPTION TYPE zcx_mocka
        EXPORTING
          textid    = zcx_mocka=&gt;no_such_method
          interface = mo_mocker-&gt;mv_interface
          method    = mv_method_name.
    ENDIF.
  ENDIF.
* count &amp; verify importing parameters
  LOOP AT &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WHERE parm_kind = lv_param_kind.
    ADD 1 TO lv_actual_parameter_count.
  ENDLOOP.
  IF lv_parameter_count &gt; lv_actual_parameter_count.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid = zcx_mocka=&gt;invalid_parameter_count.
  ENDIF.

* map importing parameters to current method call pattern
  DATA ls_importing LIKE LINE OF ms_current_method_call_pattern-importing.&quot;has the same structure as exporting arguments
  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.

  LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = lv_param_kind.
    ADD 1 TO lv_index.
    CASE lv_index.
      WHEN 1.
        GET REFERENCE OF i_p1 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 2.
        GET REFERENCE OF i_p2 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 3.
        GET REFERENCE OF i_p3 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 4.
        GET REFERENCE OF i_p4 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 5.
        GET REFERENCE OF i_p5 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 6.
        GET REFERENCE OF i_p6 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 7.
        GET REFERENCE OF i_p7 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 8.
        GET REFERENCE OF i_p8 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
    ENDCASE.
    ls_importing-parameter = &lt;ls_parameter&gt;-name.
    IF iv_is_importing = abap_true.
      APPEND ls_importing TO ms_current_method_call_pattern-importing.
    ELSE.
      APPEND ls_importing TO ms_current_method_call_pattern-changing_in.
    ENDIF.
  ENDLOOP.

  ro_self = me.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" VERSION="1" LANGU="E" DESCRIPT="verifies if two values are equal" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&amp;---------------------------------------------------------------------*
*&amp;       Class Lcl_Assert
*&amp;---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
Type-Pools: Abap.</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class
define ASSERT_WRONG_STATE.
 assert CONDITION 0 = 1.
end-of-definition.</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <textPool>
   <language SPRAS="E">
    <textElement ID="I" KEY="100" ENTRY="{Invalid Data Reference}" LENGTH="30 "/>
    <textElement ID="I" KEY="101" ENTRY="{Invalid Object Reference}" LENGTH="30 "/>
    <textElement ID="I" KEY="102" ENTRY="{Nesting Too Deep}" LENGTH="30 "/>
   </language>
  </textPool>
  <classDocumentation OBJECT="ZCL_MOCKA_VALUE_COMPARISON">
   <language SPRAS="E">
    <textLine TDFORMAT="U1" TDLINE="&amp;FUNCTIONALITY&amp;"/>
    <textLine TDFORMAT="AS" TDLINE="The class CL_ABAP_UNIT_ASSERT contains the following static methods for"/>
    <textLine TDLINE="the verification of test expectations within"/>
    <textLine TDFORMAT="=" TDLINE=" &lt;DS:ABEN.ABAP_UNIT_GLOSRY&gt;ABAP Unit&lt;/&gt; test methods:"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_EQUALS&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure the equality of two data objects. Please note that the arguments"/>
    <textLine TDLINE="are passed by reference. Objects are tested for identity only. Please"/>
    <textLine TDLINE="stick to the method ASSERT_THAT and the interface"/>
    <textLine TDFORMAT="=" TDLINE="&lt;DS:IF.IF_CONSTRAINT&gt;IF_CONSTRAINT&lt;/&gt; for custom assertions."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_EQUALS_FLOAT&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure the equality of two decimal floats with a relative tolerance."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_DIFFERS&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure the value of two data objects not to be equal."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_BOUND&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure whether the reference of a reference variable is valid."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_NOT_BOUND&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure whether the reference of a reference variable is invalid."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_INITIAL&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that a data object has its initial value."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_NOT_INITIAL&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that a data object does not have its initial value."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_SUBRC&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Requests specific value of SY-SUBRC."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_TABLE_CONTAINS &lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that a internal table contains a certain line."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_TEXT_MATCHES &lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that a text matches to a"/>
    <textLine TDFORMAT="=" TDLINE=" &lt;DS:ABEN.REGEX_SYNTAX&gt;regular expression&lt;/&gt;."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_THAT &lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that the actual value adheres to a given"/>
    <textLine TDFORMAT="=" TDLINE="&lt;DS:IF.IF_CONSTRAINT&gt;Constraint&lt;/&gt;."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;FAIL&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Terminate the test with an unconditional error."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ABORT&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Cancel the test due to a missing prerequisite."/>
    <textLine TDFORMAT="AS" TDLINE="All the methods have the optional importing parameters MSG, LEVEL, and"/>
    <textLine TDLINE="QUIT, which always have the same meaning:"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;MSG&lt;/&gt; (Type: CSEQUENCE)"/>
    <textLine TDFORMAT="/" TDLINE="Contains a more detailed description of the error (if applicable)"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;LEVEL&lt;/&gt; (Type: AUNIT_LEVEL)"/>
    <textLine TDFORMAT="/" TDLINE="Indicates the severity of the error; the following values are possible:"/>
    <textLine TDFORMAT="B2" TDLINE="TOLERABLE - Minor error (may be tolerable)"/>
    <textLine TDFORMAT="B2" TDLINE="CRITICAL - Critical error (default value)"/>
    <textLine TDFORMAT="B2" TDLINE="FATAL    - Fatal error"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;QUIT&lt;/&gt; (Type: AUNIT_FLOWCTRL)"/>
    <textLine TDFORMAT="/" TDLINE="Determines the flow control in the case of an error. The following"/>
    <textLine TDLINE="values can be passed:"/>
    <textLine TDFORMAT="B2" TDLINE="NO - No termination in the case of an error; processing of the current"/>
    <textLine TDLINE="method continues after the relevant method is called"/>
    <textLine TDFORMAT="B2" TDLINE="METHOD  - The currently processed test method is terminated (default"/>
    <textLine TDLINE="value)"/>
    <textLine TDFORMAT="B2" TDLINE="CLASS   - The currently processed test class is terminated"/>
    <textLine TDFORMAT="B2" TDLINE="PROGRAM - The test of the currently processed main program is"/>
    <textLine TDLINE="terminated: The current test class is terminated and all other test"/>
    <textLine TDLINE="classes in the program are ignored."/>
    <textLine TDFORMAT="AS" TDLINE="All the assert methods have the following mandatory importing parameter:"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ACT&lt;/&gt; (Type: Any)"/>
    <textLine TDFORMAT="/" TDLINE="The object to be verified"/>
    <textLine TDFORMAT="AS" TDLINE="The comparing method ASSERT_EQUALS additionally requires a parameter for"/>
    <textLine TDLINE="the expectation:"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;EXP&lt;/&gt; (Type: Any)"/>
    <textLine TDFORMAT="/" TDLINE="The identically expected object"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;TOL&lt;/&gt; (Type: f)"/>
    <textLine TDFORMAT="/" TDLINE="Allows you to compare floating point numbers for the passed tolerance"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;FURTHER_SOURCES_OF_INF&amp;"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;DS:KENO.3F7182087A5E002FE10000000A1148F9&gt;Knowledge Warehouse&lt;/&gt;"/>
    <textLine TDFORMAT="B1" TDLINE="Package SABP_UNIT_SAMPLE"/>
   </language>
  </classDocumentation>
  <typeUsage CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <typeClasDef CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" TYPEGROUP="CL_AUNIT_ASSERT" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="RTOL_MIN" VERSION="1" LANGU="D" DESCRIPT="Minimum Tolerance for comparsion type F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTVALUE="&apos;1.E-15&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="F" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="ASSERT_EQUALS" VERSION="1" LANGU="D" DESCRIPT="Ensure Equality of Two Data Objects" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="ASSERT_EQUALS" SCONAME="EXP" VERSION="1" LANGU="D" DESCRIPT="Data Object with Expected Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="ASSERT_EQUALS" SCONAME="ACT" VERSION="1" LANGU="D" DESCRIPT="Data Object with Current Value" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="ASSERT_EQUALS" SCONAME="RV_EQUALS" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>METHOD assert_equals.
  DATA lo_type TYPE REF TO cl_abap_typedescr.
  rv_equals = abap_true.
  TRY.
      IF exp EQ act.
        rv_equals = abap_true.
      ELSE.
        rv_equals = abap_false.
      ENDIF.
    CATCH cx_root.
      rv_equals = abap_false.
  ENDTRY.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_MOCKA" VERSION="1" LANGU="E" DESCRIPT="Root exception class of mockA" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZMOCKA_EXC_MOCK" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CX_NO_CHECK">
  <implementing CLSNAME="ZCX_MOCKA" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCX_MOCKA" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="ABSTRACT_EXCEPTION" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="22 " SRCCOLUMN1="4 " SRCROW2="29 " SRCCOLUMN2="28 " LOCKED="X" TYPESRC_LENG="316 " TYPESRC="begin of ABSTRACT_EXCEPTION,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;008&apos;,
      attr1 type scx_attrname value &apos;EXCEPTION&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of ABSTRACT_EXCEPTION
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="EXCEPTION" VERSION="1" LANGU="D" DESCRIPT="Object Type Name" EXPOSURE="2" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCLSNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="GENERIC_TEXT" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="INTERFACE" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="INVALID_EXCEPTION" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="40 " SRCCOLUMN1="4 " SRCROW2="47 " SRCCOLUMN2="27 " LOCKED="X" TYPESRC_LENG="314 " TYPESRC="begin of INVALID_EXCEPTION,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;007&apos;,
      attr1 type scx_attrname value &apos;EXCEPTION&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of INVALID_EXCEPTION
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="INVALID_PARAMETER_COUNT" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="49 " SRCCOLUMN1="4 " SRCROW2="56 " SRCCOLUMN2="33 " LOCKED="X" TYPESRC_LENG="317 " TYPESRC="begin of INVALID_PARAMETER_COUNT,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;001&apos;,
      attr1 type scx_attrname value &apos;&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of INVALID_PARAMETER_COUNT
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="METHOD" VERSION="1" LANGU="D" DESCRIPT="Full Component Name" EXPOSURE="2" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCPDNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_CHANGING_PARAMETERS" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="31 " SRCCOLUMN1="4 " SRCROW2="38 " SRCCOLUMN2="32 " LOCKED="X" TYPESRC_LENG="330 " TYPESRC="begin of NO_CHANGING_PARAMETERS,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;009&apos;,
      attr1 type scx_attrname value &apos;METHOD&apos;,
      attr2 type scx_attrname value &apos;INTERFACE&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_CHANGING_PARAMETERS
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_EXPORTING_PARAMETERS" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="76 " SRCCOLUMN1="4 " SRCROW2="83 " SRCCOLUMN2="33 " LOCKED="X" TYPESRC_LENG="332 " TYPESRC="begin of NO_EXPORTING_PARAMETERS,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;004&apos;,
      attr1 type scx_attrname value &apos;METHOD&apos;,
      attr2 type scx_attrname value &apos;INTERFACE&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_EXPORTING_PARAMETERS
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_RETURNING_PARAMETERS" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="67 " SRCCOLUMN1="4 " SRCROW2="74 " SRCCOLUMN2="33 " LOCKED="X" TYPESRC_LENG="332 " TYPESRC="begin of NO_RETURNING_PARAMETERS,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;005&apos;,
      attr1 type scx_attrname value &apos;METHOD&apos;,
      attr2 type scx_attrname value &apos;INTERFACE&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_RETURNING_PARAMETERS
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_SUCH_EXCEPTION" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="58 " SRCCOLUMN1="4 " SRCROW2="65 " SRCCOLUMN2="27 " LOCKED="X" TYPESRC_LENG="329 " TYPESRC="begin of NO_SUCH_EXCEPTION,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;006&apos;,
      attr1 type scx_attrname value &apos;EXCEPTION&apos;,
      attr2 type scx_attrname value &apos;METHOD&apos;,
      attr3 type scx_attrname value &apos;INTERFACE&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_SUCH_EXCEPTION
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_SUCH_INTERFACE" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="94 " SRCCOLUMN1="4 " SRCROW2="101 " SRCCOLUMN2="27 " LOCKED="X" TYPESRC_LENG="314 " TYPESRC="begin of NO_SUCH_INTERFACE,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;002&apos;,
      attr1 type scx_attrname value &apos;INTERFACE&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_SUCH_INTERFACE
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_SUCH_METHOD" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="85 " SRCCOLUMN1="4 " SRCROW2="92 " SRCCOLUMN2="24 " LOCKED="X" TYPESRC_LENG="314 " TYPESRC="begin of NO_SUCH_METHOD,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;003&apos;,
      attr1 type scx_attrname value &apos;METHOD&apos;,
      attr2 type scx_attrname value &apos;INTERFACE&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_SUCH_METHOD
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="UNIT_TEST_EXEC_NOT_ALLOWED" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="11 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="103 " SRCCOLUMN1="4 " SRCROW2="110 " SRCCOLUMN2="36 " LOCKED="X" TYPESRC_LENG="323 " TYPESRC="begin of UNIT_TEST_EXEC_NOT_ALLOWED,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;010&apos;,
      attr1 type scx_attrname value &apos;&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of UNIT_TEST_EXEC_NOT_ALLOWED
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="ZCX_MOCKA" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="20 " SRCCOLUMN2="19 " LOCKED="X" TYPESRC_LENG="301 " TYPESRC="begin of ZCX_MOCKA,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;000&apos;,
      attr1 type scx_attrname value &apos;GENERIC_TEXT&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of ZCX_MOCKA
"/>
  <inheritance CLSNAME="ZCX_MOCKA" REFCLSNAME="CX_NO_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" VERSION="1" LANGU="E" DESCRIPT="observes flights and triggers conditional alerts" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <textPool>
   <language SPRAS="E"/>
  </textPool>
  <attribute CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="MO_ALERT_PROCESSOR" VERSION="1" LANGU="D" DESCRIPT="Mocking Framework Beispiel: Alert-Prozessor" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="MO_IS_IN_TIME_ACCESS" VERSION="1" LANGU="D" DESCRIPT="Beispiel-Interface für Mocking-Framework Test" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_MOCKA_IS_IN_TIME_INFO" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="CONSTRUCTOR" SCONAME="IO_ALERT_PROCESSOR" VERSION="1" LANGU="D" DESCRIPT="Mocking Framework Beispiel: Alert-Prozessor" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_MOCKA_FLIGHT_ALERT_PROCESS"/>
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="CONSTRUCTOR" SCONAME="IO_IN_TIME_ACCESS" VERSION="1" LANGU="D" DESCRIPT="Beispiel-Interface für Mocking-Framework Test" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_MOCKA_IS_IN_TIME_INFO"/>
   <source>METHOD constructor.
  mo_alert_processor = io_alert_processor.
  mo_is_in_time_access = io_in_time_access.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="OBSERVE_FLIGHT" VERSION="1" LANGU="D" DESCRIPT="überprüft einen bestimmten Flug" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="OBSERVE_FLIGHT" SCONAME="IV_CARRID" VERSION="1" LANGU="D" DESCRIPT="Kurzbezeichnung der Fluggesellschaft" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="OBSERVE_FLIGHT" SCONAME="IV_CONNID" VERSION="1" LANGU="D" DESCRIPT="Code der Einzelflugverbindung" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="OBSERVE_FLIGHT" SCONAME="IV_FLDATE" VERSION="1" LANGU="D" DESCRIPT="Flugdatum" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <source>METHOD observe_flight.
  DATA lv_delay_minutes TYPE i.
  lv_delay_minutes = mo_is_in_time_access-&gt;get_delay(
    iv_carrid = iv_carrid
    iv_connid = iv_connid
    iv_fldate = iv_fldate
  ).
  IF lv_delay_minutes &gt; 60.
    mo_alert_processor-&gt;alert_delay(
      iv_carrid = iv_carrid
      iv_connid = iv_connid
      iv_fldate = iv_fldate ).
  ENDIF.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_MOCKA_IN_TIME_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Sample-Exception class for unit tests (Mocking-Framework)" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CX_STATIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_MOCKA_IN_TIME_EXCEPTION" REFCLSNAME="CX_STATIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <INTF CLSNAME="ZIF_MOCKA_MOCKER" VERSION="1" LANGU="E" DESCRIPT="describes a creator of mock objects" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <types CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="TY_S_METHOD_MOCKS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="8 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="136 " TYPESRC_LENG="133 " TYPESRC="BEGIN OF TY_S_METHOD_MOCKS,  method_name TYPE SEOCPDNAME,  method_mock TYPE REF TO ZIF_MOCKA_MOCKER_METHOD,  END OF TY_S_METHOD_MOCKS"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="TY_T_METHOD_MOCKS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="52 " TYPESRC_LENG="49 " TYPESRC="TY_T_method_mocks type TABLE OF ty_s_method_mocks"/>
  <typeUsage CLSNAME="ZIF_MOCKA_MOCKER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="GENERATE_MOCKUP" VERSION="1" LANGU="E" DESCRIPT="generiert die Attrape" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="GENERATE_MOCKUP" SCONAME="RO_MOCKUP" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="GET_INTERFACE" VERSION="1" LANGU="E" DESCRIPT="liefert das Interface der Attrappe" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="GET_INTERFACE" SCONAME="RV_INTERFACE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_ANY_METHOD_BEEN_CALLED" VERSION="1" LANGU="E" DESCRIPT="wurde irgend eine Methode aufgerufen?" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_ANY_METHOD_BEEN_CALLED" SCONAME="RV_HAS_BEEN_CALLED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_METHOD_BEEN_CALLED" VERSION="1" LANGU="E" DESCRIPT="wurde die Methode gerufen?" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_METHOD_BEEN_CALLED" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="E" DESCRIPT="Vollständiger Komponentenname" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_METHOD_BEEN_CALLED" SCONAME="RV_HAS_BEEN_CALLED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD" VERSION="1" LANGU="E" DESCRIPT="setzt die zu fälschende Methode" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="E" DESCRIPT="Vollständiger Komponentenname" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD" SCONAME="RO_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD_CALL_COUNT" VERSION="1" LANGU="E" DESCRIPT="wie oft wurde die Methode gerufen?" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD_CALL_COUNT" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="E" DESCRIPT="Vollständiger Komponentenname" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD_CALL_COUNT" SCONAME="RV_CALL_COUNT" VERSION="1" LANGU="E" DESCRIPT="Natürliche Zahl" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="INT4"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="MOCK" VERSION="1" LANGU="E" DESCRIPT="erzeugt eine neue Mocking-Instanz" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="MOCK" SCONAME="IV_INTERFACE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="MOCK" SCONAME="RO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="Beschreibt einen Mock-Erzeuger" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="registriert Aufrufparameter - IMPORTING" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="RO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_MOCKA_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="describes a method which is to be mocked" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_T_CLASS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="1" TYPE="SWF_CLASSES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_S_NAME_VALUE_PAIR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="115 " TYPESRC_LENG="112 " TYPESRC="BEGIN OF ty_s_name_value_pair,  parameter TYPE seosconame,  value TYPE REF TO data,  END OF ty_s_name_value_pair"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_T_NAME_VALUE_PAIR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="86 " TYPESRC_LENG="83 " TYPESRC="ty_t_name_value_pair TYPE STANDARD TABLE OF ty_s_name_value_pair WITH KEY parameter"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_S_METHOD_CALL_PATTERN" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="14 " SRCCOLUMN2="131 " TYPESRC_LENG="387 " TYPESRC="BEGIN OF ty_s_method_call_pattern,        importing TYPE ty_t_name_value_pair,        changing_in TYPE ty_t_name_value_pair,        changing_out TYPE ty_t_name_value_pair,        exporting TYPE ty_t_name_value_pair,        returning TYPE REF TO data,        raises TYPE REF TO cx_root,        raises_by_name TYPE seoclsname,        times_resolved TYPE i,  END OF ty_s_method_call_pattern"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_T_METHOD_CALL_PATTERN" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="16 " SRCCOLUMN1="4 " SRCROW2="16 " SRCCOLUMN2="66 " TYPESRC_LENG="63 " TYPESRC="ty_t_method_call_pattern TYPE TABLE OF ty_s_method_call_pattern"/>
  <typeUsage CLSNAME="ZIF_MOCKA_MOCKER_METHOD" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" VERSION="1" LANGU="E" DESCRIPT="registriert Rückgabeparameter - CHANGING" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" VERSION="1" LANGU="E" DESCRIPT="liefert EXPORTING-Parameter auf Basis des Aufrufes" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" SCONAME="IT_IMPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" SCONAME="ET_EXPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" SCONAME="ET_CHANGING_OUT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" VERSION="1" LANGU="E" DESCRIPT="registriert Rückgabeparameter - EXPORTING" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="FINALIZE_CURRENT_METHOD_SIGN" VERSION="1" LANGU="E" DESCRIPT="schließt die aktuelle Methodenbearbeitung ab" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="FINALIZE_CURRENT_METHOD_SIGN" SCONAME="RO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="Beschreibt einen Mockup-Erzeuger" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="GENERATE_MOCKUP" VERSION="1" LANGU="E" DESCRIPT="generiert die Attrape" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="GENERATE_MOCKUP" SCONAME="RO_MOCKUP" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="GET_ALL_RAISES_BY_NAME" VERSION="1" LANGU="E" DESCRIPT="liefert alle mit Namen registrierten Ausnahmen" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="GET_ALL_RAISES_BY_NAME" SCONAME="RT_RAISES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_CLASS"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_METHOD_BEEN_CALLED" VERSION="1" LANGU="E" DESCRIPT="wurde die Methode gerufen?" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_METHOD_BEEN_CALLED" SCONAME="RV_HAS_BEEN_CALLED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_REGISTERED_CALL_PATTERN" VERSION="1" LANGU="E" DESCRIPT="besitzt die Methode registrierte Ausgabesignaturen?" EXPOSURE="2" STATE="1" EDITORDER="17 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_REGISTERED_CALL_PATTERN" SCONAME="RV_HAS_PATTERN_REGISTERED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="INCREASE_TIMES_CALLED" VERSION="1" LANGU="E" DESCRIPT="erhöht den Methodenzähler" EXPOSURE="2" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="INCREASE_TIMES_CALLED" SCONAME="IV_INCREMENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="1"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" VERSION="1" LANGU="E" DESCRIPT="liefert eine Ausnahme, wenn für den Aufruf registriert" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" SCONAME="IT_IMPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" SCONAME="RV_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Objekttypname" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <exception CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" SCONAME="CX_STATIC_CHECK" VERSION="1" LANGU="E" DESCRIPT="Ausnahmen mit statischer und dynamischer Prüfung von RAISING" MTDTYPE="0" EDITORDER="1 "/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES" VERSION="1" LANGU="E" DESCRIPT="registriert eine Ausnahme über ein Ausnahmeobjekt" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES" SCONAME="IO_CX_ROOT" VERSION="1" LANGU="E" DESCRIPT="Abstrakte Oberklasse aller globalen Exceptions" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CX_ROOT"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES_BY_NAME" VERSION="1" LANGU="E" DESCRIPT="registriert eine Ausnahme über den Namen" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES_BY_NAME" SCONAME="IV_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Objekttypname" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES_BY_NAME" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURN" VERSION="1" LANGU="E" DESCRIPT="liefert RETURNING-Parameter auf Basis des Aufrufes" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURN" SCONAME="IT_IMPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURN" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURN" SCONAME="R_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURNS" VERSION="1" LANGU="E" DESCRIPT="registriert ein Ergebnis" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURNS" SCONAME="I_RETURN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURNS" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TIMES_CALLED" VERSION="1" LANGU="E" DESCRIPT="liefert die Anzahl der Aufrufe an die Methode" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TIMES_CALLED" SCONAME="RV_TIMES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" VERSION="1" LANGU="E" DESCRIPT="registriert Aufrufparameter - IMPORTING" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" VERSION="1" LANGU="E" DESCRIPT="registriert Aufrufparameter - CHANGING" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" VERSION="1" LANGU="E" DESCRIPT="Mocking Framework example: Alert-Processor" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <method CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" VERSION="1" LANGU="E" DESCRIPT="Alert auslösen wegen einer Verspätung auslösen" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" SCONAME="IV_CARRID" VERSION="1" LANGU="E" DESCRIPT="Kurzbezeichnung der Fluggesellschaft" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" SCONAME="IV_CONNID" VERSION="1" LANGU="E" DESCRIPT="Code der Einzelflugverbindung" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" DESCRIPT="Flugdatum" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <parameter CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" SCONAME="RV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" VERSION="1" LANGU="E" DESCRIPT="Sample-Interface for Mocking-Framework Test" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <attribute CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GC_NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="IV_CARRID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="IV_CONNID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="EV_DELAY" VERSION="1" LANGU="E" DESCRIPT="Delay in Minutes" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="EV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" SCONAME="IV_CARRID" VERSION="1" LANGU="E" DESCRIPT="Kurzbezeichnung der Fluggesellschaft" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID" PARVALUE="&apos;LH&apos;"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" SCONAME="IV_CONNID" VERSION="1" LANGU="E" DESCRIPT="Code der Einzelflugverbindung" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID" PARVALUE="402"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" DESCRIPT="Flugdatum" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE" PARVALUE="&apos;20121124&apos;"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" SCONAME="RV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" SCONAME="IV_CARRID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" SCONAME="IV_CONNID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" SCONAME="RV_DELAY" VERSION="1" LANGU="E" DESCRIPT="Delay in Minutes" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="INT4"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" SCONAME="IV_CARRID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" SCONAME="IV_CONNID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" SCONAME="RV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <exception CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" SCONAME="ZCX_MOCKA_IN_TIME_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Beispiel-Exception für Mocking Bibliothek Unit Tests" MTDTYPE="0" EDITORDER="1 "/>
  </method>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" SCONAME="IV_CARRID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" SCONAME="IV_CONNID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" SCONAME="EV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" SCONAME="CV_FLDATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <exception CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" SCONAME="ZCX_MOCKA_IN_TIME_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Beispiel-Exception für Mocking Bibliothek Unit Tests" MTDTYPE="0" EDITORDER="1 "/>
  </method>
 </INTF>
 <PROG NAME="ZTEST_CL_MOCKA_FLIGHT_OBSERVER" VARCL="X" SUBC="1" RMAND="001" RLOAD="D" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="D">
    <textElement ID="R" ENTRY="Programm ZTEST_CL_MOCKA_FLIGHT_OBSERVER" LENGTH="39 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZTEST_CL_MOCKA_FLIGHT_OBSERVER
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

* mockA is a mocking framework for ABAP that makes creating mock implementations easier than ever before. It is Open Source.
*   lead developers:
*     Uwe Kunath - kunath.uwe[at]googlemail.com
*
*   Copyright 2013 Uwe Kunath
*    mockA can be found at https://github.com/uweku/mockA/
*
*   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.

REPORT  ztest_cl_mocka_flight_observer.
*========================================================================================================
*a manually implemented mock class might look like this. This demo shows how you can save this effort...
**----------------------------------------------------------------------*
**       CLASS lcl_flight_info DEFINITION
**----------------------------------------------------------------------*
**
**----------------------------------------------------------------------*
*CLASS lcl_flight_info DEFINITION.
*  PUBLIC SECTION.
*    INTERFACES ZIF_MOCKA_IS_IN_TIME_INFO.
*ENDCLASS.                    &quot;lcl_flight_info DEFINITION
**----------------------------------------------------------------------*
**       CLASS lcl_flight_info IMPLEMENTATION
**----------------------------------------------------------------------*
**
**----------------------------------------------------------------------*
*CLASS lcl_flight_info IMPLEMENTATION.
*  METHOD ZIF_MOCKA_IS_IN_TIME_INFO~get_delay.
*    IF iv_carrid = &apos;LH&apos; AND iv_connid = 402 AND iv_fldate = &apos;20121109&apos;.
*      rv_delay = 100.
*    ENDIF.
*    IF iv_carrid = &apos;LH&apos; AND iv_connid = 402 AND iv_fldate = &apos;2012110&apos;.
*      rv_delay = 5.
*    ENDIF.
*  ENDMETHOD.                    &quot;ZIF_MOCKA_IS_IN_TIME_INFO~get_delay
*ENDCLASS.                    &quot;lcl_flight_info IMPLEMENTATION
*
*METHOD setup.
** this call creates the flight information mockup
*  CREATE OBJECT mo_is_in_time_access TYPE lcl_flight_info.
** create an empty alert backend (we just need to track the number of method calls)
*  CREATE OBJECT mo_alert_processor_mocker TYPE lcl_alert_process.
** create the flight observer which is subject to this test
*  CREATE OBJECT mo_system_under_test
*    EXPORTING
*      io_alert_processor = mo_alert_processor
*      io_in_time_access  = mo_is_in_time_access.
*ENDMETHOD. &quot;setup
*========================================================================================================

*----------------------------------------------------------------------*
*       CLASS lcl_test_observer DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_observer DEFINITION FOR TESTING.
  &quot;#AU Risk_Level Harmless
  &quot;#AU Duration Short
  PROTECTED SECTION.

    DATA mo_is_in_time_access TYPE REF TO zif_mocka_is_in_time_info .
    DATA mo_is_in_time_mocker TYPE REF TO zif_mocka_mocker.
    DATA mo_alert_processor TYPE REF TO zif_mocka_flight_alert_process .
    DATA mo_alert_processor_mocker TYPE REF TO zif_mocka_mocker.

    DATA mo_system_under_test TYPE REF TO zcl_mocka_flight_observer.

  PRIVATE SECTION.
    METHODS setup.
    METHODS teardown.
    METHODS test_no_alert FOR TESTING.
    METHODS test_with_alert FOR TESTING.
ENDCLASS.                    &quot;lcl_test_observer DEFINITION


*----------------------------------------------------------------------*
*       CLASS lcl_test_observer IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_observer IMPLEMENTATION.
  METHOD setup.
**   Member attributes:
*    DATA mo_is_in_time_access TYPE REF TO ZIF_MOCKA_IS_IN_TIME_INFO .
*    DATA mo_is_in_time_mocker TYPE REF TO ZIF_MOCKA_MOCKER.

    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
*   create the flight information backend
    mo_is_in_time_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
    lo_mocker_method = mo_is_in_time_mocker-&gt;method( &apos;GET_DELAY&apos; ).
    lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
    lo_mocker_method-&gt;returns( 100 ).
    lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; ).
    lo_mocker_method-&gt;returns( 5 ).
*   this call creates the flight information mockup
    mo_is_in_time_access ?= mo_is_in_time_mocker-&gt;generate_mockup( ).

**   Member attributes
*    DATA mo_alert_processor TYPE REF TO ZIF_MOCKA_FLIGHT_ALERT_PROCESS .
*    DATA mo_alert_processor_mocker TYPE REF TO ZIF_MOCKA_MOCKER.

*   create an empty alert backend (we just need to track the number of method calls)
    mo_alert_processor_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_FLIGHT_ALERT_PROCESS&apos; ).
*   this call creates the alert processor mockup
    mo_alert_processor ?= mo_alert_processor_mocker-&gt;generate_mockup( ).

*   create the flight observer which is subject to this test
    CREATE OBJECT mo_system_under_test
      EXPORTING
        io_alert_processor = mo_alert_processor
        io_in_time_access  = mo_is_in_time_access.
  ENDMETHOD.                    &quot;setup
  METHOD teardown.
  ENDMETHOD.                    &quot;teardown
  METHOD test_no_alert.
    DATA lv_alert TYPE abap_bool.
    mo_system_under_test-&gt;observe_flight( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121110&apos; ).
    lv_alert = mo_alert_processor_mocker-&gt;has_method_been_called( &apos;ALERT_DELAY&apos; ).
    cl_aunit_assert=&gt;assert_initial( lv_alert ).
  ENDMETHOD.                    &quot;test_no_alert
  METHOD test_with_alert.
    DATA lv_alert TYPE abap_bool.
    mo_system_under_test-&gt;observe_flight( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
    lv_alert = mo_alert_processor_mocker-&gt;has_method_been_called( &apos;ALERT_DELAY&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lv_alert ).
  ENDMETHOD.                    &quot;test_with_alert
ENDCLASS.                    &quot;lcl_test_observer IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZTEST_CL_MOCKA_MOCKER" VARCL="X" SUBC="1" RSTAT="T" RMAND="001" RLOAD="D" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="D">
    <textElement ID="R" ENTRY="Programm ZTEST_CL_MOCKA_MOCKER" LENGTH="30 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZTEST_CL_MOCKA_MOCKER
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

* mockA is a mocking framework for ABAP that makes creating mock implementations easier than ever before. It is Open Source.
*   lead developers:
*     Uwe Kunath - kunath.uwe[at]googlemail.com
*
*   Copyright 2013 Uwe Kunath
*    mockA can be found at https://github.com/uweku/mockA/
*
*   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.

REPORT  ztest_cl_mocka_mocker.

TYPE-POOLS: abap.

*The mocker which is tested here is expected to dynamically generate a mockup if type ZIF_MOCKA_IS_IN_TIME_INFO

*----------------------------------------------------------------------*
*       CLASS lcl_test_mocker DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_mocker DEFINITION FOR TESTING.
  &quot;#AU Risk_Level Harmless
  &quot;#AU Duration Short
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS setup.
    METHODS teardown.
    METHODS create_valid_mocker FOR TESTING.
    METHODS create_invalid_mocker FOR TESTING.
    METHODS create_valid_mocker_method FOR TESTING.
    METHODS create_retrieve_mocker_method FOR TESTING.
    METHODS create_invalid_mocker_method FOR TESTING.
    METHODS mock_method_params FOR TESTING.
    METHODS mock_is_in_time FOR TESTING.
    METHODS mock_get_delay FOR TESTING.
    METHODS mock_get_both FOR TESTING.
    METHODS mock_raises_exception FOR TESTING.
    METHODS mock_changing_params FOR TESTING.
    METHODS mock_optional_params FOR TESTING.
    METHODS mock_get_delay_x2 FOR TESTING.
    METHODS mock_raises_exc_x2 FOR TESTING.
    METHODS mock_changing_par_x2 FOR TESTING.
    METHODS mock_included_interface_method FOR TESTING.
    METHODS mock_method_with_old_exc FOR TESTING.
ENDCLASS.                    &quot;lcl_test_mocker DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_test_mocker IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_mocker IMPLEMENTATION.
  METHOD setup.
  ENDMETHOD.                    &quot;setup
  METHOD teardown.
  ENDMETHOD.                    &quot;teardown
  METHOD create_valid_mocker.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_not_initial( lo_mocker ).
  ENDMETHOD.                    &quot;create_valid_mocker
  METHOD create_invalid_mocker.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;\PROGRAM=ZTEST_CL_MOCKA_MOCKER\INTERFACE=LIF_INVALID&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_initial( lo_mocker ).
  ENDMETHOD.                    &quot;create_valid_mocker

  METHOD create_valid_mocker_method.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_not_initial( lo_mocker ).
    cl_aunit_assert=&gt;assert_not_initial( lo_mocker_method ).
  ENDMETHOD.                    &quot;create_valid_mocker_method
  METHOD create_retrieve_mocker_method.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method1 TYPE REF TO zif_mocka_mocker_method.
    DATA  lv_mm1_eq_mm2 TYPE abap_bool.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method1 = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.

*   any new method results in a new instance...
    DATA lo_mocker_method2 TYPE REF TO zif_mocka_mocker_method.
    TRY.
        lo_mocker_method2 = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
    IF lo_mocker_method1 EQ lo_mocker_method2.
      lv_mm1_eq_mm2 = abap_true.
    ELSE.
      lv_mm1_eq_mm2 = abap_false.
    ENDIF.
    cl_aunit_assert=&gt;assert_initial( lv_mm1_eq_mm2 ).

*   ...but any method which has already been requested returns the existing instance
    TRY.
        lo_mocker_method2 = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

    IF lo_mocker_method1 EQ lo_mocker_method2.
      lv_mm1_eq_mm2 = abap_true.
    ELSE.
      lv_mm1_eq_mm2 = abap_false.
    ENDIF.
    cl_aunit_assert=&gt;assert_not_initial( lv_mm1_eq_mm2 ).
  ENDMETHOD.                    &quot;create_and_retrieve_mocker_method
  METHOD create_invalid_mocker_method.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;INVALID&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_not_initial( lo_mocker ).
    cl_aunit_assert=&gt;assert_initial( lo_mocker_method ).
  ENDMETHOD.                    &quot;create_invalid_mocker_method

  METHOD mock_method_params.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = 20121108 ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

*   create invalid parameter combination
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = 20121108 i_p4 = &apos;INVALID_PARAM&apos;).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).


*   create valid parameter combination - using RETURNING parameter
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    CLEAR: lv_has_exception_been_raised.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;returns( abap_true ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).



*   create valid parameter combination - using EXPORTING parameters
    CLEAR: lv_has_exception_been_raised.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_BOTH&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;exports( i_p1 = 10 i_p2 = abap_false ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

*   create invalid parameter combination - using EXPORTING parameters
    CLEAR: lv_has_exception_been_raised.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_BOTH&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; i_p4 = &apos;INVALID&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_method_params

  METHOD mock_is_in_time.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.
    DATA lv_flag TYPE abap_bool.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;returns( abap_true ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( abap_false ).
*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; )-&gt;returns( abap_true ).
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; )-&gt;returns( abap_false ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

*       call interface methods of the mockup - IS_IN_TIME
        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

*       verify number of calls for IS_IN_TIME
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 2 ).
        lv_flag = lo_mocker_method-&gt;has_method_been_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_flag exp = abap_true ).
        lv_flag = lo_mocker-&gt;has_any_method_been_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_flag exp = abap_true ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock

  METHOD mock_get_delay.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( 10 ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; ).
        lo_mocker_method-&gt;returns( 5 ).

*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; )-&gt;returns( 10 ).
*        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; )-&gt;returns( 5 ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

*       call interface methods of the mockup - GET_DELAY
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 10 ).
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121110&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 5 ).

*       not registered calls should not lead to any exception
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121111&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 0 ).

*       verify number of calls for GET_DELAY
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 3 ).


      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
  ENDMETHOD.                    &quot;mock_GET_DELAY

  METHOD mock_get_both.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
*       create valid parameter combination - using EXPORTING parameters
        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_BOTH&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;exports( i_p1 = 10 i_p2 = abap_false ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;exports( i_p1 = 2 i_p2 = abap_true ).

*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; )-&gt;exports( i_p1 = 10 i_p2 = abap_false ).
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; )-&gt;exports( i_p1 = 2 i_p2 = abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        lo_in_time-&gt;get_both(
            EXPORTING iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos;
            IMPORTING ev_delay = lv_delay ev_is_in_time = lv_is_in_time ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 2 ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

        lo_in_time-&gt;get_both(
            EXPORTING iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos;
            IMPORTING ev_delay = lv_delay ev_is_in_time = lv_is_in_time ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 10 ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

        &quot;default values
        lo_in_time-&gt;get_both(
            EXPORTING iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121110&apos;
            IMPORTING ev_delay = lv_delay ev_is_in_time = lv_is_in_time ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 0 ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

*       verify number of calls for GET_BOTH
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 3 ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_get_both

  METHOD mock_raises_exception.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
*       create valid parameter combination - using EXPORTING parameters
        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).

        TRY.
            lv_has_exception_been_raised = abap_false.
            lo_mocker_method-&gt;raises_by_name( &apos;CX_STATIC_CHECK&apos; ).&quot;invalid exception - is abstract
          CATCH zcx_mocka.
            lv_has_exception_been_raised = abap_true.
        ENDTRY.
        cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
        lv_has_exception_been_raised = abap_false.

        lo_mocker_method-&gt;raises_by_name( &apos;ZCX_MOCKA_IN_TIME_EXCEPTION&apos; ).&quot;intentionally name the valid exception in lower case

        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( abap_false ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).
        TRY.
            lv_has_exception_been_raised = abap_false.
            lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
          CATCH zcx_mocka_in_time_exception.
            lv_has_exception_been_raised = abap_true.
          CATCH cx_root.
            lv_has_exception_been_raised = abap_false.&quot;since it is the wrong exception
        ENDTRY.
        cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
        lv_has_exception_been_raised = abap_false.

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_raises_exception

  METHOD mock_changing_params.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    DATA lv_fldate TYPE s_date.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
*       create valid parameter combination - using EXPORTING parameters
        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME_BY_CHANGING_PARAM&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121108&apos; ).
        lo_mocker_method-&gt;exports( abap_false ).

        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121109&apos; ).
        lo_mocker_method-&gt;exports( abap_true ).

        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121123&apos; ).
        lo_mocker_method-&gt;changes( &apos;20121124&apos; ).
        lo_mocker_method-&gt;exports( abap_true ).

*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 )-&gt;with_changing( &apos;20121108&apos; )-&gt;exports( i_p1 = 10 i_p2 = abap_false ).
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 )-&gt;with_changing( &apos;20121109&apos; )-&gt;exports( i_p1 = 2 i_p2 = abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121109&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.

        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121108&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121123&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        cl_aunit_assert=&gt;assert_equals( act = lv_fldate exp = &apos;20121124&apos; ).


      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_changing_params
  METHOD mock_optional_params.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.
    DATA lv_flag TYPE abap_bool.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_BY_OPTIONAL_PARAMS&apos; ).
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).&quot;intentionally left blank - should always return a specific value
        lo_mocker_method-&gt;returns( abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

*       call interface methods of the mockup - GET_BY_OPTIONAL_PARAMS
        lv_is_in_time = lo_in_time-&gt;get_by_optional_params( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        lv_is_in_time = lo_in_time-&gt;get_by_optional_params( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

*       verify number of calls for GET_BY_OPTIONAL_PARAMS
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 2 ).
        lv_flag = lo_mocker_method-&gt;has_method_been_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_flag exp = abap_true ).
        lv_flag = lo_mocker-&gt;has_any_method_been_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_flag exp = abap_true ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_optional_params
  METHOD mock_get_delay_x2.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( 10 ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( 5 ).

*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; )-&gt;returns( 10 ).
*        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; )-&gt;returns( 5 ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

*       call interface methods of the mockup - GET_DELAY
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 10 ).
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 5 ).

*       not registered calls should not lead to any exception
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121111&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 0 ).

*       verify number of calls for GET_DELAY
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 3 ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_get_delay_x2
  METHOD mock_raises_exc_x2.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).

        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;raises_by_name( &apos;ZCX_MOCKA_IN_TIME_EXCEPTION&apos; ).&quot;intentionally name the valid exception in lower case

        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;returns( abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        TRY.
            lv_has_exception_been_raised = abap_false.
            lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
            cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

          CATCH zcx_mocka_in_time_exception.
            lv_has_exception_been_raised = abap_true.
          CATCH cx_root.
            lv_has_exception_been_raised = abap_false.&quot;since it is the wrong exception
        ENDTRY.
        cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).

*       call second pattern twice
        lv_has_exception_been_raised = abap_false.
        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

        lv_has_exception_been_raised = abap_false.
        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).


      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_raises_exc_x2
  METHOD mock_changing_par_x2.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    DATA lv_fldate TYPE s_date.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME_BY_CHANGING_PARAM&apos; ).
*       create valid parameter combination - using EXPORTING parameters
        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121123&apos; ).
        lo_mocker_method-&gt;changes( &apos;20121124&apos; ).
        lo_mocker_method-&gt;exports( abap_false ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121123&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).
        cl_aunit_assert=&gt;assert_equals( act = lv_fldate exp = &apos;20121124&apos; ).

        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121123&apos; ).
        lo_mocker_method-&gt;exports( abap_true ).

*       call second pattern twice
        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121123&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        cl_aunit_assert=&gt;assert_equals( act = lv_fldate exp = &apos;20121123&apos; ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121123&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        cl_aunit_assert=&gt;assert_equals( act = lv_fldate exp = &apos;20121123&apos; ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_changing_par_x2
  METHOD mock_included_interface_method.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    DATA lo_fake TYPE REF TO ifc2dir_change_cont_int.

    DATA lv_subrc TYPE i.
    DATA lv_subrc_copy TYPE i.
    lv_subrc = 2.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;IFC2DIR_CHANGE_CONT_INT&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;ifc2dir_change_context~is_user_in_chng_cont&apos; ).&quot;currently only works for method aliases
        lo_mocker_method-&gt;with( sy-uname ).
        lo_mocker_method-&gt;returns( lv_subrc ).
        lo_fake ?= lo_mocker-&gt;generate_mockup( ).
        lv_subrc_copy = lo_fake-&gt;ifc2dir_change_context~is_user_in_chng_cont( sy-uname ).

        cl_aunit_assert=&gt;assert_equals( act = lv_subrc exp = lv_subrc_copy ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_included_interface_method
  METHOD mock_method_with_old_exc.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    DATA lo_fake TYPE REF TO if_http_client.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;IF_HTTP_CLIENT&apos; ).
        lo_fake ?= lo_mocker-&gt;generate_mockup( ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock_method_with_old_exc
ENDCLASS.                    &quot;lcl_test_mocker IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZMOCKA_DEMO" VARCL="X" SUBC="1" RSTAT="T" RMAND="001" RLOAD="D" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="D">
    <textElement ID="R" ENTRY="Programm ZMOCKA_DEMO" LENGTH="20 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZMOCKA_DEMO
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

* mockA is a mocking framework for ABAP that makes creating mock implementations easier than ever before. It is Open Source.
*   lead developers:
*     Uwe Kunath - kunath.uwe[at]googlemail.com
*
*   Copyright 2013 Uwe Kunath
*    mockA can be found at https://github.com/uweku/mockA/
*
*   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.

REPORT  zmocka_demo.

DATA lo_mocker TYPE REF TO zif_mocka_mocker.
DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( zif_mocka_is_in_time_info=&gt;gc_name ).

DATA lo_is_in_time_into TYPE REF TO zif_mocka_is_in_time_info.
DATA lv_delay TYPE i.
DATA lv_has_been_called TYPE abap_bool.
DATA lv_call_count TYPE i.

lo_mocker_method = lo_mocker-&gt;method( &apos;get_delay&apos; ).
lo_mocker_method-&gt;with(
    i_p1             = &apos;LH&apos;
    i_p2             = &apos;300&apos;
    i_p3             = sy-datlo
).
lo_mocker_method-&gt;returns( 100 ).

*in NW &gt;= 7.02 you may also use:
*lo_mocker-&gt;method( &apos;get_delay&apos; )-&gt;with(
*    i_p1             = &apos;LH&apos;
*    i_p2             = &apos;300&apos;
*    i_p3             = sy-datlo
*)-&gt;returns( 100 ).

lo_is_in_time_into ?= lo_mocker-&gt;generate_mockup( ).
lv_has_been_called = lo_mocker-&gt;has_method_been_called( &apos;get_delay&apos; ).
WRITE: &apos;called?&apos;, lv_has_been_called.
NEW-LINE.

lo_is_in_time_into-&gt;get_delay(
  EXPORTING
    iv_carrid = &apos;LH&apos;
    iv_connid = &apos;300&apos;
    iv_fldate = sy-datlo
  RECEIVING
    rv_delay  = lv_delay
).
WRITE: &apos;Delay:&apos;, lv_delay.
NEW-LINE.

lv_has_been_called = lo_mocker-&gt;has_method_been_called( &apos;get_delay&apos; ).
WRITE: &apos;called?&apos;, lv_has_been_called.
NEW-LINE.
lv_call_count = lo_mocker-&gt;method_call_count( &apos;get_delay&apos; ).
WRITE: &apos;call count&apos;, lv_call_count.</source>
 </PROG>
 <MSAG ARBGB="ZMOCKA_EXC_MOCK" MASTERLANG="E" RESPUSER="KUNATHU">
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="000" TEXT="&amp;1"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="000" TEXT="&amp;1"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="001" TEXT="Ungültige Anzahl an Parametern übergeben"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="001" TEXT="Invalid parameter count in method call"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="002" TEXT="Das Interface &amp;1 ist unbekannt"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="002" TEXT="The interface &amp;1 is unknown"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="003" TEXT="Die Methode &amp;1 des Interfaces &amp;2 ist unbekannt"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="003" TEXT="Method &amp;1 of interface &amp;2 is unknown"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="004" TEXT="Die Methode &amp;1 des Interfaces &amp;2 besitzt keine EXPORTING-Parameter"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="004" TEXT="Method &amp;1 of interface &amp;2 has no EXPORTING parameters"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="005" TEXT="Die Methode &amp;1 des Interfaces &amp;2 besitzt keine RETURNING-Parameter"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="005" TEXT="Method &amp;1 of interface &amp;2 has no RETURNING parameters"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="006" TEXT="Die Ausnahme &amp;1 existiert nicht für die Methode &amp;2 des Interfaces &amp;2"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="006" TEXT="Exception &amp;1 not known in method &amp;2 of interface &amp;3"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="007" TEXT="&amp;1 ist keine gültige Exception-Klasse"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="007" TEXT="&amp;1 is not a valid exception class"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="008" TEXT="&amp;1 ist eine abstrakte Exception-Klasse und kann nicht verwendet"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="008" TEXT="&amp;1 is an abstract exception class and cannot be used"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="009" TEXT="Die Methode &amp;1 des Interfaces &amp;2 besitzt keine CHANGING-Parameter"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="009" TEXT="Method &amp;1 of interface &amp;2 has no CHANGING parameters"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="010" TEXT="Unit Tests können nicht ausgeführt werden. Siehe SAUNIT_CLIENT_SETUP"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="010" TEXT="Unit Test execution is not allowed in this client=&gt;Tx SAUNIT_CLIENT_SETUP"/>
  <t100t SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" STEXT="Message class for exception texts (ZCX_MOCKA)"/>
 </MSAG>
</nugget>
