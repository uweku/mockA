<?xml version="1.0" encoding="utf-8"?>
<nugget name="E:\Git\mockA\build\mockA_daily.nugg">
 <CLAS CLSNAME="ZCL_MOCKA_HELPER_MOCKER" VERSION="1" LANGU="D" DESCRIPT="Helper class for ZCL_MOCKA_MOCKER" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <textPool>
   <language SPRAS="E"/>
  </textPool>
  <method CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" SCONAME="IT_CODE" VERSION="1" LANGU="E" DESCRIPT="Table of strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING_TABLE"/>
   <parameter CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" SCONAME="EV_PROG" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" SCONAME="EV_SUBRC" VERSION="1" LANGU="E" DESCRIPT="return value of ABAP statement" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <parameter CLSNAME="ZCL_MOCKA_HELPER_MOCKER" CMPNAME="GENERATE_SUBROUTINE_POOL" SCONAME="EV_MESSAGE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <source>METHOD generate_subroutine_pool.
* helper method that generates the local class that implements the mock object functions
  FREE: ev_prog,
        ev_subrc,
        ev_message.

  CATCH SYSTEM-EXCEPTIONS generate_subpool_dir_full = 9.
    GENERATE SUBROUTINE POOL it_code NAME ev_prog MESSAGE ev_message.
    IF sy-subrc IS NOT INITIAL.
      ev_subrc = sy-subrc.
    ENDIF.
  ENDCATCH.
  IF sy-subrc = 9.
    ev_subrc = sy-subrc.
    ev_message = text-001.
  ENDIF.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_MOCKA_MOCKER" VERSION="1" LANGU="D" DESCRIPT="implements the creator of mock objects" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TY_S_METHODS" VERSION="1" LANGU="D" DESCRIPT="beschreibt eine zu simulierende Methode" EXPOSURE="1" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="6 " SRCCOLUMN2="127 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_s_methods,    name TYPE seocpdname,    method_mocker TYPE REF TO zif_mocka_mocker_method,    END OF ty_s_methods
"/>
  <types CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TY_S_ATTRIBUTES" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="8 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="139 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_s_attributes,    name TYPE seocpdname,    attribute_mocker TYPE REF TO zif_mocka_mocker_attribute,    END OF ty_s_attributes
"/>
  <types CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TY_T_METHODS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="42 " TYPESRC_LENG="0 " TYPESRC="ty_t_methods TYPE TABLE OF ty_s_methods
"/>
  <types CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TY_T_ATTRIBUTES" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="4 " SRCROW2="12 " SRCCOLUMN2="48 " TYPESRC_LENG="0 " TYPESRC="ty_t_attributes TYPE TABLE OF ty_s_attributes
"/>
  <types CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TY_S_GENERATED_CLASS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="14 " SRCCOLUMN1="4 " SRCROW2="14 " SRCCOLUMN2="120 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ty_s_generated_class,    name TYPE seoclsname,    technical_name TYPE string,    END OF ty_s_generated_class
"/>
  <friends CLSNAME="ZCL_MOCKA_MOCKER" REFCLSNAME="ZCL_MOCKA_MOCKER_METHOD" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <implementing CLSNAME="ZCL_MOCKA_MOCKER" REFCLSNAME="ZIF_MOCKA_MOCKER" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <forwardDeclaration>SEOS</forwardDeclaration>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GC_VISIBILITY" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="10 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="27 " SRCCOLUMN1="4 " SRCROW2="31 " SRCCOLUMN2="34 " TYPESRC_LENG="276 " TYPESRC="BEGIN OF gc_visibility,
                public TYPE abap_visibility VALUE &apos;U&apos;,      &quot;#EC NOTEXT
                protected TYPE abap_visibility VALUE &apos;O&apos;,   &quot;#EC NOTEXT
                private TYPE abap_visibility VALUE &apos;I&apos;,     &quot;#EC NOTEXT
               END OF gc_visibility
"/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MO_OBJECTDESCR" VERSION="1" LANGU="D" DESCRIPT="Run Time Type Services" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_ABAP_OBJECTDESCR" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MT_ATTRIBUTE_MOCKS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_T_ATTRIBUTES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MT_CONSTRUCTOR_PARAMETERS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_PARMBIND_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MT_GENERATED_CLASSES" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="7 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="23 " SRCCOLUMN1="4 " SRCROW2="23 " SRCCOLUMN2="58 " TYPESRC_LENG="56 " TYPESRC="mt_generated_classes TYPE TABLE OF ty_s_generated_class
"/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MT_METHOD_MOCKS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER=&gt;TY_T_METHOD_MOCKS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MV_GENERATED_CLASS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MV_INTERFACE" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MV_IS_INTERFACE_MOCK" VERSION="1" LANGU="D" DESCRIPT="Ist ein Interface zu mocken?" EXPOSURE="1" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="MV_MOCK_COUNT" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~ATTRIBUTE">
   <source>METHOD zif_mocka_mocker~attribute.
*   specify the values for a faked attribute
    FIELD-SYMBOLS &lt;ls_attribute&gt; TYPE abap_attrdescr.
    DATA lv_attribute_name LIKE iv_attribute.

    lv_attribute_name = iv_attribute.
    TRANSLATE lv_attribute_name TO UPPER CASE.

    DATA ls_attribute TYPE ty_s_attributes.
    READ TABLE mt_attribute_mocks INTO ls_attribute WITH KEY name = lv_attribute_name.
    IF sy-subrc = 0.
      ro_attribute = ls_attribute-attribute_mocker.
      RETURN.
    ENDIF.

    READ TABLE mo_objectdescr-&gt;attributes ASSIGNING &lt;ls_attribute&gt; WITH KEY name = lv_attribute_name.
    IF &lt;ls_attribute&gt; IS NOT ASSIGNED.
      RAISE EXCEPTION TYPE zcx_mocka
        EXPORTING
          textid    = zcx_mocka=&gt;no_such_attribute
          interface = mv_interface
          attribute = lv_attribute_name.
    ENDIF.

    CREATE OBJECT ro_attribute
      TYPE
      zcl_mocka_mocker_attribute
      EXPORTING
        iv_attribute = lv_attribute_name
        io_mocker    = me.

    ls_attribute-attribute_mocker ?= ro_attribute.
    ls_attribute-name = lv_attribute_name.
    APPEND ls_attribute TO mt_attribute_mocks.
  ENDMETHOD.                    &quot;zif_mocka_mocker~attribute</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~GENERATE_MOCKUP">
   <source>METHOD zif_mocka_mocker~generate_mockup.
* This method generates the mockup class code
* every instance receives the instance of the current mocker to carry out method parameter verifications,
* as well as recordings of incoming parameters of method calls

  DATA lv_has_returning_parameter TYPE abap_bool VALUE abap_false.
  DATA lv_has_exporting_parameter TYPE abap_bool VALUE abap_false.
  DATA lv_has_changing_parameter TYPE abap_bool VALUE abap_false.

  ro_mockup ?= try_create_by_generated_class( ).
  CHECK: ro_mockup IS INITIAL.

  FIELD-SYMBOLS &lt;ls_method_mock&gt; LIKE LINE OF mt_method_mocks.
  LOOP AT mt_method_mocks ASSIGNING &lt;ls_method_mock&gt;.
    &lt;ls_method_mock&gt;-method_mock-&gt;finalize_current_method_sign( ).
  ENDLOOP.

  ADD 1 TO mv_mock_count.
  DATA lt_code  TYPE TABLE OF string.
  DATA lt_temp_code  TYPE TABLE OF string.
  DATA lv_prog  TYPE string.
  DATA lv_line TYPE string.
  FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mo_objectdescr-&gt;methods.
  FIELD-SYMBOLS &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_classname TYPE seoclsname.
  DATA: lv_exception TYPE seoclsname.
  DATA lv_message TYPE string.
  DATA lv_inheriting_from TYPE string.
  DATA lv_generate_method TYPE abap_bool.
  DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
  DATA lv_code_redefinition TYPE string.
  DATA lv_string TYPE string.

  APPEND `program.`                     TO lt_code.
  lv_string = mv_mock_count.
  CONCATENATE &apos;LCL_IMPL&apos; lv_string INTO lv_string.
  lv_classname = lv_string.
  IF mv_is_interface_mock = abap_false.
    CONCATENATE &apos;INHERITING FROM&apos; mv_interface INTO lv_inheriting_from SEPARATED BY space.
  ENDIF.
  CONCATENATE &apos;CLASS&apos; lv_classname &apos;DEFINITION&apos; lv_inheriting_from &apos;.&apos; INTO lv_line SEPARATED BY space.
  APPEND lv_line TO lt_code.

  DATA lv_is_public_section TYPE abap_bool VALUE abap_true.
  DO 2 TIMES.
    IF lv_is_public_section = abap_true.
      APPEND &apos;PUBLIC SECTION.&apos; TO lt_code.
      IF mv_is_interface_mock = abap_true.
        CONCATENATE &apos;INTERFACES&apos; mv_interface &apos;.&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_code.
      ENDIF.
    ELSE.
      APPEND &apos;PROTECTED SECTION.&apos; TO lt_code.
      APPEND &apos;DATA: mo_mocker TYPE REF TO ZIF_MOCKA_MOCKER.&apos; TO lt_code. &quot;#EC NOTEXT
    ENDIF.
    IF mv_is_interface_mock = abap_false.
      LOOP AT mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WHERE is_class = abap_false AND name NE &apos;CONSTRUCTOR&apos;.
        IF lv_is_public_section = abap_true AND &lt;ls_method&gt;-visibility = gc_visibility-protected
          OR lv_is_public_section = abap_false AND &lt;ls_method&gt;-visibility = gc_visibility-public
          OR &lt;ls_method&gt;-visibility = gc_visibility-private.
          CONTINUE.
        ENDIF.

        CLEAR: lv_has_changing_parameter, lv_has_exporting_parameter, lv_has_returning_parameter.
        lv_generate_method = abap_false.
        lo_mocker_method = resolve_method( &lt;ls_method&gt; ).
        IF lo_mocker_method IS NOT INITIAL.
          lv_generate_method = lo_mocker_method-&gt;has_registered_call_pattern( ).
        ENDIF.
       IF lv_generate_method = abap_false and &lt;ls_method&gt;-is_abstract eq abap_false.
          CONTINUE.
        ELSE.
          lv_code_redefinition = &apos;REDEFINITION&apos;.
        ENDIF.

*       create method stub
        lv_line = &lt;ls_method&gt;-name.

        CONCATENATE &apos;METHODS&apos; lv_line lv_code_redefinition &apos;.&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_code.
      ENDLOOP.
    ENDIF.

    IF lv_is_public_section = abap_true.
      generate_constructor_def(
        CHANGING
          ct_code = lt_code
      ).

      lv_is_public_section = abap_false.
    ENDIF.
  ENDDO.
  APPEND &apos;ENDCLASS.&apos; TO lt_code.

  CONCATENATE &apos;CLASS&apos; lv_classname &apos;IMPLEMENTATION.&apos; INTO lv_line SEPARATED BY space.
  APPEND lv_line TO lt_code.

  generate_constructor(
    CHANGING
      ct_code   = lt_code    &quot; Table of Strings
  ).

  LOOP AT mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WHERE is_class = abap_false.
    CLEAR: lv_has_changing_parameter, lv_has_exporting_parameter, lv_has_returning_parameter.

    lo_mocker_method = resolve_method( &lt;ls_method&gt; ).
    IF mv_is_interface_mock = abap_false.&quot;is method relevant for generation?
      lv_generate_method = abap_false.
      IF lo_mocker_method IS NOT INITIAL.
        lv_generate_method = lo_mocker_method-&gt;has_registered_call_pattern( ).
      ENDIF.
      IF lv_generate_method = abap_false and &lt;ls_method&gt;-is_abstract eq abap_false.
        CONTINUE.
      ENDIF.
    ENDIF.

* create method stub
    IF mv_is_interface_mock = abap_true.
      CONCATENATE mv_interface &apos;~&apos; &lt;ls_method&gt;-name INTO lv_line.
    ELSE.
      lv_line = &lt;ls_method&gt;-name.
    ENDIF.

    CONCATENATE &apos;METHOD&apos; lv_line &apos;.&apos; INTO lv_line SEPARATED BY space.
    APPEND lv_line TO lt_code.
    CLEAR: lv_line.

    generate_method_declarations(
      EXPORTING
        is_method = &lt;ls_method&gt;
      CHANGING
        ct_code   = lt_code
    ).

*   map IMPORTING parameters
    generate_importing_param_map(
      EXPORTING
        is_method = &lt;ls_method&gt;
      CHANGING
        ct_code   = lt_code
    ).
*   map CHANGING parameters
    generate_changing_param_map(
      EXPORTING
        is_method =  &lt;ls_method&gt;
      CHANGING
        ct_code   = lt_code
    ).

    generate_method_call_protocol(
      EXPORTING
        is_method = &lt;ls_method&gt;
      CHANGING
        ct_code   = lt_code
    ).
* is there any exception registered?
    generate_method_exc_raising(
      EXPORTING
        is_method = &lt;ls_method&gt;
      CHANGING
        ct_code   = lt_code    &quot; Table of Strings
    ).

* call mocker method to retrieve values
    READ TABLE &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WITH KEY parm_kind = &apos;E&apos;.
    IF sy-subrc = 0.
      lv_has_exporting_parameter = abap_true.
    ENDIF.

    READ TABLE &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WITH KEY parm_kind = &apos;C&apos;.
    IF sy-subrc = 0.
      lv_has_changing_parameter = abap_true.
    ENDIF.
    READ TABLE &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WITH KEY parm_kind = &apos;R&apos;.
    IF sy-subrc = 0.
      lv_has_returning_parameter = abap_true.
    ENDIF.

    IF lv_has_changing_parameter = abap_true OR lv_has_exporting_parameter = abap_true.
      APPEND &apos;CALL METHOD lo_mocker_method-&gt;export&apos; TO lt_code. &quot;#EC NOTEXT
    ENDIF.

    IF lv_has_returning_parameter = abap_true.
      APPEND &apos;CALL METHOD lo_mocker_method-&gt;return&apos; TO lt_code. &quot;#EC NOTEXT
    ENDIF.

    IF lv_has_changing_parameter = abap_true
      OR lv_has_exporting_parameter = abap_true
      OR lv_has_returning_parameter = abap_true.
      APPEND &apos;EXPORTING it_importing = lt_importing it_changing_in = lt_changing_in&apos; TO lt_code. &quot;#EC NOTEXT
    ENDIF.

* map RETURNING parameter, if any
    IF lv_has_returning_parameter = abap_true.
      APPEND &apos;RECEIVING&apos; TO lt_code.
      APPEND &apos;r_result = lr_return.&apos; TO lt_code.            &quot;#EC NOTEXT
      READ TABLE &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WITH KEY parm_kind = &apos;R&apos;.
      IF sy-subrc = 0.
        APPEND &apos;IF lr_return IS BOUND.&apos; TO lt_code.         &quot;#EC NOTEXT
        APPEND &apos;ASSIGN lr_return-&gt;* TO &lt;lv_return&gt;.&apos; TO lt_code. &quot;#EC NOTEXT
        CONCATENATE &lt;ls_parameter&gt;-name &apos; = &lt;lv_return&gt;.&apos; INTO lv_line SEPARATED BY space. &quot;#EC NOTEXT
        APPEND lv_line TO lt_code.
        APPEND &apos;ENDIF.&apos; TO lt_code.
      ENDIF.
    ELSE.
*   map EXPORTING/CHANGING parameters, if any

      IF lv_has_changing_parameter = abap_true
        OR lv_has_exporting_parameter = abap_true.
        APPEND &apos;IMPORTING&apos; TO lt_code.
      ENDIF.


      IF lv_has_exporting_parameter = abap_true.
        APPEND &apos;et_exporting = lt_exporting&apos; TO lt_code.    &quot;#EC NOTEXT
      ENDIF.
      IF lv_has_changing_parameter = abap_true.
        APPEND &apos;et_changing_out = lt_changing_out&apos; TO lt_code. &quot;#EC NOTEXT
      ENDIF.
      APPEND &apos;.&apos; TO lt_code.

      LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;E&apos;.
        CONCATENATE &apos;FREE: &apos; &lt;ls_parameter&gt;-name &apos;.&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_code.
        CONCATENATE &apos;GET REFERENCE OF&apos; &lt;ls_parameter&gt;-name &apos;into ls_exporting-value.&apos; INTO lv_line SEPARATED BY space. &quot;#EC NOTEXT
        APPEND lv_line TO lt_code.
        CONCATENATE &apos;READ TABLE lt_exporting ASSIGNING &lt;ls_exporting&gt; WITH KEY parameter = &apos;&apos;&apos; &lt;ls_parameter&gt;-name &apos;&apos;&apos;.&apos; INTO lv_line. &quot;#EC NOTEXT
        APPEND lv_line TO lt_code.
        APPEND &apos;IF sy-subrc = 0.&apos; TO lt_code.               &quot;#EC NOTEXT
        APPEND &apos;ASSIGN ls_exporting-value-&gt;* TO &lt;lv_exporting_out&gt;.&apos; TO lt_code. &quot;#EC NOTEXT
        APPEND &apos;ASSIGN &lt;ls_exporting&gt;-value-&gt;* TO &lt;lv_exporting_from_mocker&gt;.&apos; TO lt_code. &quot;#EC NOTEXT
        APPEND &apos;&lt;lv_exporting_out&gt; = &lt;lv_exporting_from_mocker&gt;.&apos; TO lt_code. &quot;#EC NOTEXT
        APPEND &apos;ENDIF.&apos; TO lt_code.                         &quot;#EC NOTEXT
      ENDLOOP.

      LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
        IF &lt;ls_parameter&gt;-is_optional = abap_true.
          CONCATENATE &apos;IF&apos; &lt;ls_parameter&gt;-name &apos;IS SUPPLIED.&apos; INTO lv_line SEPARATED BY space.
        ENDIF.
        APPEND lv_line TO lt_code.
        CONCATENATE &apos;GET REFERENCE OF&apos; &lt;ls_parameter&gt;-name &apos;into ls_changing_out-value.&apos; INTO lv_line SEPARATED BY space. &quot;#EC NOTEXT
        APPEND lv_line TO lt_code.
        CONCATENATE &apos;READ TABLE lt_changing_out ASSIGNING &lt;ls_exporting&gt; WITH KEY parameter = &apos;&apos;&apos; &lt;ls_parameter&gt;-name &apos;&apos;&apos;.&apos; INTO lv_line. &quot;#EC NOTEXT
        APPEND lv_line TO lt_code.
        APPEND &apos;IF sy-subrc = 0.&apos; TO lt_code.               &quot;#EC NOTEXT
        APPEND &apos;ASSIGN ls_changing_out-value-&gt;* TO &lt;lv_exporting_out&gt;.&apos; TO lt_code. &quot;#EC NOTEXT
        APPEND &apos;ASSIGN &lt;ls_exporting&gt;-value-&gt;* TO &lt;lv_exporting_from_mocker&gt;.&apos; TO lt_code. &quot;#EC NOTEXT
        APPEND &apos;&lt;lv_exporting_out&gt; = &lt;lv_exporting_from_mocker&gt;.&apos; TO lt_code. &quot;#EC NOTEXT
        APPEND &apos;ENDIF.&apos; TO lt_code.
        IF &lt;ls_parameter&gt;-is_optional = abap_true.
          APPEND &apos;ENDIF.&apos; TO lt_code.
        ENDIF.
      ENDLOOP.

    ENDIF.
    APPEND &apos;ENDMETHOD.&apos; TO lt_code.
  ENDLOOP.
  APPEND &apos;ENDCLASS.&apos; TO lt_code.

  DATA: lv_subrc LIKE sy-subrc.

  CALL METHOD zcl_mocka_helper_mocker=&gt;generate_subroutine_pool
    EXPORTING
      it_code    = lt_code
    IMPORTING
      ev_message = lv_message
      ev_prog    = lv_prog
      ev_subrc   = lv_subrc.
  IF lv_subrc NE 0.
    raise_exception( lv_message ).
  ENDIF.

  CONCATENATE `\PROGRAM=` lv_prog `\CLASS=` lv_classname INTO mv_generated_class.
  ro_mockup ?= try_create_by_generated_class( ).

  DATA ls_generated_class TYPE ty_s_generated_class.
  IF mv_is_interface_mock = abap_true.
    ls_generated_class-name = mv_interface.
    ls_generated_class-technical_name = mv_generated_class.
    APPEND ls_generated_class TO mt_generated_classes.
  ENDIF.
ENDMETHOD.                    &quot;ZIF_MOCKA_MOCKER~generate_mockup</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~GET_INTERFACE">
   <source>METHOD zif_mocka_mocker~get_interface.
    rv_interface = mv_interface.
  ENDMETHOD.                    &quot;ZIF_MOCKA_MOCKER~get_interface</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~HAS_ANY_METHOD_BEEN_CALLED">
   <source>METHOD zif_mocka_mocker~has_any_method_been_called.
    FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mt_method_mocks.
    LOOP AT mt_method_mocks ASSIGNING &lt;ls_method&gt;.
      rv_has_been_called = &lt;ls_method&gt;-method_mock-&gt;has_method_been_called( ).
      IF rv_has_been_called = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    &quot;ZIF_MOCKA_MOCKER~has_any_method_been_called</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~HAS_METHOD_BEEN_CALLED">
   <source>METHOD zif_mocka_mocker~has_method_been_called.
*   determines, if a certain method has already been called by the generated mock object
    DATA lv_call_count TYPE i.
    DATA lv_method LIKE iv_method_name.
    lv_method = iv_method_name.
    TRANSLATE lv_method TO UPPER CASE.

    CALL METHOD me-&gt;zif_mocka_mocker~method_call_count
      EXPORTING
        iv_method_name = lv_method
      RECEIVING
        rv_call_count  = lv_call_count.
    IF lv_call_count &gt; 0.
      rv_has_been_called = abap_true.
    ELSE.
      rv_has_been_called = abap_false.
    ENDIF.
  ENDMETHOD.                    &quot;ZIF_MOCKA_MOCKER~has_method_been_called</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~METHOD">
   <source>METHOD zif_mocka_mocker~method.
*   resolves the requested method object
    FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
    DATA lv_method_name LIKE iv_method_name.

    lv_method_name = iv_method_name.
    TRANSLATE lv_method_name TO UPPER CASE.

    DATA ls_method TYPE ty_s_methods.
    READ TABLE mt_method_mocks INTO ls_method WITH KEY method_name = lv_method_name.
    IF sy-subrc = 0.
      ro_method = ls_method-method_mocker.
      RETURN.
    ENDIF.

    READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = lv_method_name.
    IF sy-subrc NE 0.
      READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY alias_for = lv_method_name.
    ENDIF.

    IF &lt;ls_method&gt; IS NOT ASSIGNED.
      RAISE EXCEPTION TYPE zcx_mocka
        EXPORTING
          textid    = zcx_mocka=&gt;no_such_method
          interface = mv_interface
          method    = lv_method_name.
    ENDIF.

    CREATE OBJECT ro_method TYPE zcl_mocka_mocker_method
      EXPORTING
        iv_method_name = lv_method_name
        io_mocker      = me.

    ls_method-method_mocker = ro_method.
    ls_method-name = lv_method_name.
    APPEND ls_method TO mt_method_mocks.
  ENDMETHOD.                    &quot;ZIF_MOCKA_MOCKER~method</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~METHOD_CALL_COUNT">
   <source>METHOD zif_mocka_mocker~method_call_count.
*   determines, how often the specified method has already been called by the generated mock object
    FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mt_method_mocks.
    DATA lv_method_name LIKE iv_method_name.
    lv_method_name = iv_method_name.
    TRANSLATE lv_method_name TO UPPER CASE.

    READ TABLE mt_method_mocks ASSIGNING &lt;ls_method&gt; WITH KEY method_name = lv_method_name.
    IF sy-subrc = 0.
      rv_call_count = &lt;ls_method&gt;-method_mock-&gt;times_called( ).
    ENDIF.
  ENDMETHOD.                    &quot;ZIF_MOCKA_MOCKER~method_call_count</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~MOCK">
   <source>METHOD zif_mocka_mocker~mock.
*   returns a new mock object instance that provides the root object for recording &amp; generating the mock object behaviour
    DATA lo_mocker TYPE REF TO zcl_mocka_mocker.
    DATA lo_typedescr TYPE REF TO cl_abap_typedescr.
    DATA lo_cx_root TYPE REF TO cx_root.
    DATA lv_message TYPE string.
    FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
    DATA lv_interface LIKE iv_interface.

    check_unit_test_execution( ).

    lv_interface = iv_interface.
    TRANSLATE lv_interface TO UPPER CASE.

    CREATE OBJECT lo_mocker.

    CALL METHOD cl_abap_intfdescr=&gt;describe_by_name
      EXPORTING
        p_name         = lv_interface
      RECEIVING
        p_descr_ref    = lo_typedescr
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2.
    IF sy-subrc NE 0.
      RAISE EXCEPTION TYPE zcx_mocka
        EXPORTING
          textid    = zcx_mocka=&gt;no_such_interface
          interface = iv_interface.
    ENDIF.

    IF lo_typedescr-&gt;type_kind = cl_abap_typedescr=&gt;typekind_class.
      lo_mocker-&gt;mv_is_interface_mock = abap_false.
    ELSE.
      lo_mocker-&gt;mv_is_interface_mock = abap_true.
    ENDIF.

    TRY.
        ro_mocker = lo_mocker.
        lo_mocker-&gt;mo_objectdescr ?= lo_typedescr.
        lo_mocker-&gt;mv_interface = lv_interface.
        LOOP AT lo_mocker-&gt;mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt;.
          lo_mocker-&gt;resolve_method( &lt;ls_method&gt; ).
        ENDLOOP.

        DATA ls_generated_class TYPE ty_s_generated_class.
        READ TABLE mt_generated_classes INTO ls_generated_class WITH KEY name = lv_interface.
        IF sy-subrc = 0.
          lo_mocker-&gt;mv_generated_class = ls_generated_class-technical_name.
        ENDIF.
      CATCH cx_root INTO lo_cx_root.
        lv_message = lo_cx_root-&gt;get_text( ).
        RAISE EXCEPTION TYPE zcx_mocka
          EXPORTING
            textid       = zcx_mocka=&gt;zcx_mocka
            generic_text = lv_message.
    ENDTRY.

  ENDMETHOD.                    &quot;ZIF_MOCKA_MOCKER~mock</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER" CPDNAME="ZIF_MOCKA_MOCKER~PASS_TO_SUPER_CONSTRUCTOR">
   <source>METHOD zif_mocka_mocker~pass_to_super_constructor.
*   this method specifies the super contructor parameters, in case the current mock will be derived by a class instead of an interface
    DATA ls_param LIKE LINE OF mt_constructor_parameters.
    FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mo_objectdescr-&gt;methods.
    FIELD-SYMBOLS &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
    DATA lr_value TYPE REF TO data.
    CLEAR: mt_constructor_parameters.

    READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = &apos;CONSTRUCTOR&apos;.
    IF sy-subrc = 0.
      LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;I&apos; OR parm_kind = &apos;C&apos;.
        CLEAR: lr_value.
        CASE sy-tabix.
          WHEN 1.
            IF i_p1 IS SUPPLIED.
              GET REFERENCE OF i_p1 INTO lr_value.
            ENDIF.
          WHEN 2.
            IF i_p2 IS SUPPLIED.
              GET REFERENCE OF i_p2 INTO lr_value.
            ENDIF.
          WHEN 3.
            IF i_p3 IS SUPPLIED.
              GET REFERENCE OF i_p3 INTO lr_value.
            ENDIF.
          WHEN 4.
            IF i_p4 IS SUPPLIED.
              GET REFERENCE OF i_p4 INTO lr_value.
            ENDIF.
          WHEN 5.
            IF i_p5 IS SUPPLIED.
              GET REFERENCE OF i_p5 INTO lr_value.
            ENDIF.
          WHEN 6.
            IF i_p6 IS SUPPLIED.
              GET REFERENCE OF i_p6 INTO lr_value.
            ENDIF.
          WHEN 7.
            IF i_p7 IS SUPPLIED.
              GET REFERENCE OF i_p7 INTO lr_value.
            ENDIF.
          WHEN 8.
            IF i_p8 IS SUPPLIED.
              GET REFERENCE OF i_p8 INTO lr_value.
            ENDIF.
        ENDCASE.

        IF lr_value IS BOUND.
          ls_param-value = copy_value( lr_value ).
          ls_param-name = &lt;ls_parameter&gt;-name.

          IF &lt;ls_parameter&gt;-parm_kind = &apos;I&apos;.
            ls_param-kind = &apos;E&apos;.
          ENDIF.
          IF &lt;ls_parameter&gt;-parm_kind = &apos;E&apos;.
            ls_param-kind = &apos;I&apos;.
          ENDIF.
          IF &lt;ls_parameter&gt;-parm_kind = &apos;C&apos;.
            ls_param-kind = &apos;C&apos;.
          ENDIF.
          INSERT ls_param INTO TABLE mt_constructor_parameters.
        ENDIF.
      ENDLOOP.
    ELSE.
*     @todo: proper exception handling
    ENDIF.
    ro_mocker = me.
  ENDMETHOD.                    &quot;ZIF_MOCKA_MOCKER~pass_to_super_constructor</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="CHECK_UNIT_TEST_EXECUTION" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD check_unit_test_execution.
    DATA lv_is_unit_test_allowed TYPE abap_bool.
    lv_is_unit_test_allowed = cl_aunit_permission_control=&gt;is_test_enabled_client( ).
    IF lv_is_unit_test_allowed = abap_false.
      RAISE EXCEPTION TYPE zcx_mocka
        EXPORTING
          textid = zcx_mocka=&gt;unit_test_exec_not_allowed.
    ENDIF.
  ENDMETHOD.                    &quot;check_unit_test_execution</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="COPY_VALUE" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="COPY_VALUE" SCONAME="IR_REF" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="COPY_VALUE" SCONAME="RR_REF" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD copy_value.
    FIELD-SYMBOLS &lt;lv_in&gt; TYPE any.
    FIELD-SYMBOLS &lt;lv_out&gt; TYPE any.

    ASSIGN ir_ref-&gt;* TO &lt;lv_in&gt;.
    CREATE DATA rr_ref LIKE &lt;lv_in&gt;.
    ASSIGN rr_ref-&gt;* TO &lt;lv_out&gt;.
    &lt;lv_out&gt; = &lt;lv_in&gt;.
  ENDMETHOD.                    &quot;COPY_VALUE</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_CHANGING_PARAM_MAP" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_CHANGING_PARAM_MAP" SCONAME="IS_METHOD" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_METHDESCR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_CHANGING_PARAM_MAP" SCONAME="CT_CODE" VERSION="1" LANGU="D" DESCRIPT="Table of Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING_TABLE"/>
   <source>METHOD generate_changing_param_map.
* generates the CHANGING parameter mapping for the mock object&apos;s method source code
  DATA lv_line TYPE string.
  FIELD-SYMBOLS &lt;ls_parameter&gt; LIKE LINE OF is_method-parameters.
  LOOP AT is_method-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
    CONCATENATE &apos;ls_changing_in-parameter = &apos;&apos;&apos; &lt;ls_parameter&gt;-name &apos;&apos;&apos;.&apos; INTO lv_line. &quot;#EC NOTEXT
    APPEND lv_line TO ct_code.
    IF &lt;ls_parameter&gt;-is_optional = abap_true.
      CONCATENATE &apos;IF&apos; &lt;ls_parameter&gt;-name &apos;IS SUPPLIED.&apos; INTO lv_line SEPARATED BY space.
    ENDIF.
    APPEND lv_line TO ct_code.
    CONCATENATE &apos;GET REFERENCE OF&apos; &lt;ls_parameter&gt;-name &apos;into ls_changing_in-value.&apos; INTO lv_line SEPARATED BY space. &quot;#EC NOTEXT
    APPEND lv_line TO ct_code.
    APPEND &apos;APPEND ls_changing_in TO lt_changing_in.&apos; TO ct_code. &quot;#EC NOTEXT
    IF &lt;ls_parameter&gt;-is_optional = abap_true.
      APPEND &apos;ENDIF.&apos; TO ct_code.
    ENDIF.
  ENDLOOP.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_CONSTRUCTOR" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_CONSTRUCTOR" SCONAME="CT_CODE" VERSION="1" LANGU="D" DESCRIPT="Table of Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING_TABLE"/>
   <source>METHOD generate_constructor.
  FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mo_objectdescr-&gt;methods.
  DATA lt_temp_code  TYPE TABLE OF string.
  FIELD-SYMBOLS &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_line TYPE string.

  APPEND &apos;METHOD constructor.&apos; TO ct_code.                  &quot;#EC NOTEXT
  IF mv_is_interface_mock = abap_false.
    APPEND &apos;call method super-&gt;constructor&apos; TO ct_code.     &quot;#EC NOTEXT
    READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = &apos;CONSTRUCTOR&apos;.
    IF sy-subrc = 0.
      CLEAR: lt_temp_code.
      LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;I&apos;.
        READ TABLE mt_constructor_parameters TRANSPORTING NO FIELDS WITH KEY name = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          CONCATENATE &lt;ls_parameter&gt;-name &apos;=&apos; &lt;ls_parameter&gt;-name INTO lv_line SEPARATED BY space.
          APPEND lv_line TO lt_temp_code.
        ENDIF.
      ENDLOOP.
      IF lt_temp_code IS NOT INITIAL.
        APPEND &apos;EXPORTING&apos; TO ct_code.
        APPEND LINES OF lt_temp_code TO ct_code.
      ENDIF.
      CLEAR: lt_temp_code.
      LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
        READ TABLE mt_constructor_parameters TRANSPORTING NO FIELDS WITH KEY name = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          CONCATENATE &lt;ls_parameter&gt;-name &apos;=&apos; &lt;ls_parameter&gt;-name INTO lv_line SEPARATED BY space.
          CONCATENATE &lt;ls_parameter&gt;-name &apos;=&apos; &lt;ls_parameter&gt;-name INTO lv_line SEPARATED BY space.
          APPEND lv_line TO lt_temp_code.
        ENDIF.
      ENDLOOP.
      IF lt_temp_code IS NOT INITIAL.
        APPEND &apos;CHANGING&apos; TO ct_code.
        APPEND LINES OF lt_temp_code TO ct_code.
      ENDIF.
    ENDIF.
    APPEND &apos;.&apos; TO ct_code.
  ENDIF.
  APPEND &apos;mo_mocker = io_mocker.&apos; TO ct_code.               &quot;#EC NOTEXT

  APPEND &apos;DATA lo_attribute TYPE REF TO zif_mocka_mocker_attribute.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;FIELD-SYMBOLS &lt;l_value&gt; TYPE ANY.&apos; TO ct_code.    &quot;#EC NOTEXT
  APPEND &apos;DATA lr_value TYPE REF TO data.&apos; TO ct_code.      &quot;#EC NOTEXT

  FIELD-SYMBOLS &lt;ls_attribute&gt; TYPE abap_attrdescr.
  DATA lo_attribute TYPE REF TO zif_mocka_mocker_attribute.
  DATA lr_value TYPE REF TO data.
  DATA lv_attribute TYPE string.
  FIELD-SYMBOLS &lt;l_value&gt; TYPE any.
  LOOP AT mo_objectdescr-&gt;attributes ASSIGNING &lt;ls_attribute&gt; WHERE is_constant = abap_false.
    IF &lt;ls_attribute&gt;-visibility = gc_visibility-private.&quot;no mocking of private attributes
      CONTINUE.
    ENDIF.

    lo_attribute = me-&gt;zif_mocka_mocker~attribute( &lt;ls_attribute&gt;-name ).

    CONCATENATE &apos;lo_attribute = mo_mocker-&gt;attribute( &apos;&apos;&apos; &lt;ls_attribute&gt;-name &apos;&apos;&apos; ).&apos; INTO lv_line. &quot;#EC NOTEXT
    APPEND lv_line TO ct_code.
    APPEND &apos;lr_value = lo_attribute-&gt;return( ).&apos; TO ct_code. &quot;#EC NOTEXT
    APPEND &apos;IF lr_value IS BOUND.&apos; TO ct_code.              &quot;#EC NOTEXT
    APPEND &apos;ASSIGN lr_value-&gt;* TO &lt;l_value&gt;.&apos; TO ct_code.   &quot;#EC NOTEXT
    IF mv_is_interface_mock = abap_false.
      CONCATENATE &lt;ls_attribute&gt;-name &apos;= &lt;l_value&gt;.&apos; INTO lv_line SEPARATED BY space. &quot;#EC NOTEXT
    ELSE.
      CONCATENATE mv_interface &apos;~&apos; &lt;ls_attribute&gt;-name INTO lv_line.
      CONCATENATE lv_line &apos;= &lt;l_value&gt;.&apos; INTO lv_line SEPARATED BY space. &quot;#EC NOTEXT
    ENDIF.
    APPEND lv_line TO ct_code.
    APPEND &apos;ENDIF.&apos; TO ct_code.
  ENDLOOP.
  APPEND &apos;ENDMETHOD.&apos; TO ct_code.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_CONSTRUCTOR_DEF" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_CONSTRUCTOR_DEF" SCONAME="CT_CODE" VERSION="1" LANGU="D" DESCRIPT="Table of Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING_TABLE"/>
   <source>METHOD generate_constructor_def.
* generates the constructor definition for the mock object&apos;s class source code
  FIELD-SYMBOLS &lt;ls_method&gt; LIKE LINE OF mo_objectdescr-&gt;methods.
  DATA lt_temp_code  TYPE TABLE OF string.
  FIELD-SYMBOLS &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_line TYPE string.

  APPEND &apos;METHODS constructor IMPORTING !io_mocker TYPE REF TO ZIF_MOCKA_MOCKER !it_attributes type ABAP_ATTRDESCR_TAB&apos; TO ct_code. &quot;#EC NOTEXT

  READ TABLE mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = &apos;CONSTRUCTOR&apos;.
  IF sy-subrc = 0.
    CLEAR: lt_temp_code.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;I&apos;.
      READ TABLE mt_constructor_parameters TRANSPORTING NO FIELDS WITH KEY name = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        CONCATENATE &lt;ls_parameter&gt;-name &apos;TYPE ANY&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_temp_code.
      ENDIF.
    ENDLOOP.
    IF lt_temp_code IS NOT INITIAL.
      APPEND LINES OF lt_temp_code TO ct_code.
    ENDIF.

    CLEAR: lt_temp_code.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
      READ TABLE mt_constructor_parameters TRANSPORTING NO FIELDS WITH KEY name = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        CONCATENATE &lt;ls_parameter&gt;-name &apos;TYPE ANY&apos; INTO lv_line SEPARATED BY space.
        APPEND lv_line TO lt_temp_code.
      ENDIF.
    ENDLOOP.
    IF lt_temp_code IS NOT INITIAL.
      APPEND &apos;CHANGING&apos; TO ct_code.
      APPEND LINES OF lt_temp_code TO ct_code.
    ENDIF.
  ENDIF.
  APPEND &apos;.&apos; TO ct_code.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_IMPORTING_PARAM_MAP" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_IMPORTING_PARAM_MAP" SCONAME="IS_METHOD" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_METHDESCR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_IMPORTING_PARAM_MAP" SCONAME="CT_CODE" VERSION="1" LANGU="D" DESCRIPT="Table of Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING_TABLE"/>
   <source>METHOD generate_importing_param_map.
* generates the IMPORTING parameter mapping for the mock object&apos;s method source code
  DATA lv_line TYPE string.
  FIELD-SYMBOLS &lt;ls_parameter&gt; LIKE LINE OF is_method-parameters.
  LOOP AT is_method-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;I&apos;.
    IF &lt;ls_parameter&gt;-is_optional = abap_true.
      CONCATENATE &apos;IF&apos; &lt;ls_parameter&gt;-name &apos;IS SUPPLIED.&apos; INTO lv_line SEPARATED BY space.
      APPEND lv_line TO ct_code.
    ENDIF.
    CONCATENATE &apos;ls_importing-parameter = &apos;&apos;&apos; &lt;ls_parameter&gt;-name &apos;&apos;&apos;.&apos; INTO lv_line. &quot;#EC NOTEXT
    APPEND lv_line TO ct_code.
    CONCATENATE &apos;GET REFERENCE OF&apos; &lt;ls_parameter&gt;-name &apos;into ls_importing-value.&apos; INTO lv_line SEPARATED BY space. &quot;#EC NOTEXT
    APPEND lv_line TO ct_code.
    APPEND &apos;APPEND ls_importing TO lt_importing.&apos; TO ct_code. &quot;#EC NOTEXT
    IF &lt;ls_parameter&gt;-is_optional = abap_true.
      APPEND &apos;ENDIF.&apos; TO ct_code.
    ENDIF.
  ENDLOOP.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_METHOD_CALL_PROTOCOL" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_METHOD_CALL_PROTOCOL" SCONAME="IS_METHOD" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_METHDESCR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_METHOD_CALL_PROTOCOL" SCONAME="CT_CODE" VERSION="1" LANGU="D" DESCRIPT="Table of Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING_TABLE"/>
   <source>METHOD GENERATE_METHOD_CALL_PROTOCOL.
* register method call
  APPEND &apos;lo_mocker_method_runtime ?= lo_mocker_method.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;lo_mocker_method_runtime-&gt;increase_times_called( ).&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;lo_mocker_method_runtime-&gt;REGISTER_HAS_BEEN_CALLED_WITH( it_importing = lt_importing it_changing_in = lt_changing_in ).&apos; TO ct_code. &quot;#EC NOTEXT
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_METHOD_DECLARATIONS" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_METHOD_DECLARATIONS" SCONAME="IS_METHOD" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_METHDESCR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_METHOD_DECLARATIONS" SCONAME="CT_CODE" VERSION="1" LANGU="D" DESCRIPT="Table of Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING_TABLE"/>
   <source>METHOD GENERATE_METHOD_DECLARATIONS.
* every mocked methods receives this set of local variables
  DATA lv_line TYPE string.

  APPEND &apos;DATA: lr_return TYPE REF TO DATA.&apos; TO ct_code.    &quot;#EC NOTEXT
  APPEND &apos;DATA: lv_exception TYPE seoclsname.&apos; TO ct_code.  &quot;#EC NOTEXT
  APPEND &apos;DATA: lo_mocker_method TYPE REF TO ZIF_MOCKA_MOCKER_METHOD.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;DATA: lo_mocker_method_runtime TYPE REF TO ZIF_MOCKA_MOCKER_METHOD_RUNTIM.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;FIELD-SYMBOLS: &lt;lv_return&gt; TYPE any.&apos; TO ct_code. &quot;#EC NOTEXT
  IF is_method-alias_for IS NOT INITIAL.
    CONCATENATE &apos;lo_mocker_method ?= mo_mocker-&gt;method( &apos;&apos;&apos; is_method-alias_for &apos;&apos;&apos; ).&apos; INTO lv_line. &quot;#EC NOTEXT
  ELSE.
    CONCATENATE &apos;lo_mocker_method ?= mo_mocker-&gt;method( &apos;&apos;&apos; is_method-name &apos;&apos;&apos; ).&apos; INTO lv_line. &quot;#EC NOTEXT
  ENDIF.
  APPEND lv_line TO ct_code.

  APPEND &apos;DATA ls_importing TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;DATA ls_changing_in TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;DATA ls_exporting TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;DATA ls_changing_out TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;DATA lt_importing TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;DATA lt_changing_in TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;DATA lt_exporting TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;DATA lt_changing_out TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;FIELD-SYMBOLS &lt;ls_exporting&gt; TYPE ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_NAME_VALUE_PAIR.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;FIELD-SYMBOLS &lt;lv_exporting_out&gt; TYPE any.&apos; TO ct_code. &quot;#EC NOTEXT
  APPEND &apos;FIELD-SYMBOLS &lt;lv_exporting_from_mocker&gt; TYPE any.&apos; TO ct_code. &quot;#EC NOTEXT
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_METHOD_EXC_RAISING" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_METHOD_EXC_RAISING" SCONAME="IS_METHOD" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_METHDESCR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="GENERATE_METHOD_EXC_RAISING" SCONAME="CT_CODE" VERSION="1" LANGU="D" DESCRIPT="Table of Strings" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING_TABLE"/>
   <source>METHOD GENERATE_METHOD_EXC_RAISING.
* exception raising logic for the mock object will be generated here
  DATA lv_is_class_based_exception TYPE abap_bool.
  DATA lt_exceptions TYPE seos_exceptions_r.
  FIELD-SYMBOLS &lt;ls_exception&gt; TYPE vseoexcep.
  DATA ls_method_key TYPE seocmpkey.
  DATA lv_message TYPE string.

  APPEND &apos;lv_exception = lo_mocker_method-&gt;raise( it_importing = lt_importing it_changing_in = lt_changing_in ).&apos; TO ct_code. &quot;#EC NOTEXT

  FIND FIRST OCCURRENCE OF &apos;~&apos; IN is_method-name.
  IF sy-subrc EQ 0.
    SPLIT is_method-name AT &apos;~&apos; INTO ls_method_key-clsname ls_method_key-cmpname.
  ELSE.
    ls_method_key-clsname = mv_interface.
    ls_method_key-cmpname = is_method-name.
  ENDIF.
  CALL FUNCTION &apos;SEO_METHOD_SIGNATURE_GET&apos;
    EXPORTING
      mtdkey       = ls_method_key
    IMPORTING
      exceps       = lt_exceptions
    EXCEPTIONS
      not_existing = 1
      is_event     = 2
      is_type      = 3
      is_attribute = 4
      model_only   = 5
      OTHERS       = 6.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_message.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid       = zcx_mocka=&gt;zcx_mocka
        generic_text = lv_message.
  ELSE.
    READ TABLE lt_exceptions ASSIGNING &lt;ls_exception&gt; INDEX 1.
    IF sy-subrc = 0.
      lv_is_class_based_exception = me-&gt;is_exception_class( &lt;ls_exception&gt;-sconame ).
    ENDIF.
    IF lt_exceptions IS INITIAL.
      lv_is_class_based_exception = abap_true.
    ENDIF.
  ENDIF.
  IF lv_is_class_based_exception = abap_true.
    APPEND &apos;DATA lo_cx_exc TYPE REF TO cx_root.&apos; TO ct_code. &quot;#EC NOTEXT
    APPEND &apos;IF lv_exception IS NOT INITIAL.&apos; TO ct_code.    &quot;#EC NOTEXT
    APPEND &apos;  TRANSLATE lv_exception TO UPPER CASE.&apos; TO ct_code. &quot;#EC NOTEXT
    APPEND &apos;  CREATE OBJECT lo_cx_exc TYPE (lv_exception).&apos; TO ct_code. &quot;#EC NOTEXT
    APPEND &apos;  RAISE EXCEPTION lo_cx_exc.&apos; TO ct_code.       &quot;#EC NOTEXT
    APPEND &apos;ENDIF.&apos; TO ct_code.                             &quot;#EC NOTEXT
  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="IS_EXCEPTION_CLASS" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="IS_EXCEPTION_CLASS" SCONAME="IV_CLASSNAME" VERSION="1" LANGU="D" DESCRIPT="Object Type Name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="IS_EXCEPTION_CLASS" SCONAME="RV_IS_EXCEPTION" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>METHOD is_exception_class.
    DATA ls_clskey TYPE seoclskey.
    ls_clskey-clsname = iv_classname.
    DATA ls_class TYPE seoc_class_r.
    CALL FUNCTION &apos;SEO_CLASS_READ&apos;
      EXPORTING
        clskey = ls_clskey
      IMPORTING
        class  = ls_class.
    IF ls_class-category = 40.
      rv_is_exception = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;is_exception_class</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RAISE_EXCEPTION" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RAISE_EXCEPTION" SCONAME="IV_MESSAGE" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <source>METHOD raise_exception.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid       = zcx_mocka=&gt;zcx_mocka
        generic_text = iv_message.
  ENDMETHOD.                    &quot;raise_exception</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RESOLVE_METHOD" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RESOLVE_METHOD" SCONAME="IS_METHOD" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_METHDESCR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="RESOLVE_METHOD" SCONAME="RO_METHOD_MOCK" VERSION="1" LANGU="D" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
   <source>METHOD resolve_method.
  IF is_method-alias_for IS NOT INITIAL AND mv_is_interface_mock = abap_true.
    &quot; I&apos;m not sure why this would be needed. Public and protected aliases should
    &quot; be inherited and private aliases wouldn&apos;t matter anyway?
    &quot; It&apos;s causing issues when I&apos;m mocking a class and setting the return
    &quot; value for an interface method implemented in that class that has
    &quot; an alias...
    ro_method_mock = me-&gt;zif_mocka_mocker~method( is_method-alias_for ).
  ELSE.
    ro_method_mock = me-&gt;zif_mocka_mocker~method( is_method-name ).
  ENDIF.
ENDMETHOD.                    &quot;resolve_method</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TRY_CREATE_BY_GENERATED_CLASS" VERSION="1" LANGU="D" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER" CMPNAME="TRY_CREATE_BY_GENERATED_CLASS" SCONAME="RO_MOCKUP" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
   <source>METHOD try_create_by_generated_class.
* As there is a limit of subroutine pools, mockA cannot generate a new class out of the same interface every time
* Furthermore, the code will not change, as the differing behaviour will injected with the mocker instance
* This method tries to resolve possibly existing subroutine pools that may have been created earlier and creates a new mock instance out of it

  DATA lt_constructor_parameters LIKE mt_constructor_parameters.
  DATA ls_constructor_parameter LIKE LINE OF mt_constructor_parameters.

  IF mv_generated_class IS NOT INITIAL.
    ls_constructor_parameter-name = &apos;IO_MOCKER&apos;.
    ls_constructor_parameter-kind = &apos;E&apos;.
    GET REFERENCE OF me INTO ls_constructor_parameter-value.
    INSERT ls_constructor_parameter INTO TABLE lt_constructor_parameters.

    ls_constructor_parameter-name = &apos;IT_ATTRIBUTES&apos;.
    ls_constructor_parameter-kind = &apos;E&apos;.
    GET REFERENCE OF mo_objectdescr-&gt;attributes INTO ls_constructor_parameter-value.
    INSERT ls_constructor_parameter INTO TABLE lt_constructor_parameters.

    INSERT LINES OF mt_constructor_parameters INTO TABLE lt_constructor_parameters.
    CREATE OBJECT ro_mockup
      TYPE
      (mv_generated_class)
      PARAMETER-TABLE
      lt_constructor_parameters.
    RETURN.
  ENDIF.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_MOCKA_MOCKER_METHOD" VERSION="1" LANGU="D" DESCRIPT="implements a single mock-method" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <friends CLSNAME="ZCL_MOCKA_MOCKER_METHOD" REFCLSNAME="ZCL_MOCKA_MOCKER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <implementing CLSNAME="ZCL_MOCKA_MOCKER_METHOD" REFCLSNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="2 "/>
  <implementing CLSNAME="ZCL_MOCKA_MOCKER_METHOD" REFCLSNAME="ZIF_MOCKA_MOCKER_METHOD" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER_METHOD" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER_METHOD" TYPEGROUP="SEOC" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <forwardDeclaration>SEOC</forwardDeclaration>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MO_MOCKER" VERSION="1" LANGU="D" DESCRIPT="Beschreibt einen Mock-Erzeuger" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_MOCKA_MOCKER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MT_CURRENT_METHOD_CALL_PATTERN" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="4 " SRCCOLUMN2="97 " TYPESRC_LENG="95 " TYPESRC="MT_CURRENT_METHOD_CALL_PATTERN type TABLE OF ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_METHOD_CALL_PATTERN
"/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MT_METHOD_CALLS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="6 " SRCCOLUMN2="82 " TYPESRC_LENG="80 " TYPESRC="MT_METHOD_CALLS type TABLE OF ZIF_MOCKA_MOCKER_METHOD=&gt;TY_S_METHOD_CALL_PATTERN
"/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MT_METHOD_CALL_PATTERNS" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="90 " TYPESRC_LENG="88 " TYPESRC="mt_method_call_patterns TYPE TABLE OF ZIF_MOCKA_MOCKER_method=&gt;ty_s_method_call_pattern
"/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MV_METHOD_NAME" VERSION="1" LANGU="D" DESCRIPT="Vollständiger Komponentenname" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCPDNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="MV_TIMES_CALLED" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~CHANGES">
   <source>METHOD zif_mocka_mocker_method~changes.
* registers outbound CHANGING parameters
  DATA lv_parameter_count TYPE i.
  DATA lv_actual_parameter_count TYPE i.
  DATA lr_ref TYPE REF TO data.
  FIELD-SYMBOLS &lt;lv_in&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_to&gt; TYPE any.
  ADD 1 TO lv_parameter_count.
  IF i_p2 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.

  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid    = zcx_mocka=&gt;no_such_method
        interface = mo_mocker-&gt;mv_interface
        method    = mv_method_name.
  ENDIF.
* count &amp; verify importing parameters
  LOOP AT &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WHERE parm_kind = &apos;C&apos;.
    ADD 1 TO lv_actual_parameter_count.
  ENDLOOP.
  IF lv_parameter_count &gt; lv_actual_parameter_count.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid = zcx_mocka=&gt;invalid_parameter_count.
  ENDIF.

* map importing parameters to current method call pattern
  DATA ls_changing_out TYPE zif_mocka_mocker_method=&gt;ty_s_name_value_pair.
  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.

  FIELD-SYMBOLS &lt;ls_current_call_pattern&gt; LIKE LINE OF mt_current_method_call_pattern.
  LOOP AT mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
    FREE: &lt;ls_current_call_pattern&gt;-changing_out.
  ENDLOOP.

  READ TABLE &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WITH KEY parm_kind = &apos;C&apos;.
  IF sy-subrc NE 0.
    DATA lv_interface TYPE abap_abstypename.
    lv_interface =  mo_mocker-&gt;zif_mocka_mocker~get_interface( ).
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid    = zcx_mocka=&gt;no_changing_parameters
        interface = lv_interface
        method    = mv_method_name.
  ENDIF.
  LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;C&apos;.
    ADD 1 TO lv_index.
    CASE lv_index.
      WHEN 1.
        GET REFERENCE OF i_p1 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 2.
        GET REFERENCE OF i_p2 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 3.
        GET REFERENCE OF i_p3 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 4.
        GET REFERENCE OF i_p4 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 5.
        GET REFERENCE OF i_p5 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 6.
        GET REFERENCE OF i_p6 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 7.
        GET REFERENCE OF i_p7 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
      WHEN 8.
        GET REFERENCE OF i_p8 INTO lr_ref.
        ls_changing_out-value = copy_value( lr_ref ).
    ENDCASE.
    ls_changing_out-parameter = &lt;ls_parameter&gt;-name.
    LOOP AT mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
      APPEND ls_changing_out TO &lt;ls_current_call_pattern&gt;-changing_out.
    ENDLOOP.
  ENDLOOP.

  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~EXPORT">
   <source>METHOD ZIF_MOCKA_MOCKER_method~export.
  CALL METHOD me-&gt;resolve_method_output
    EXPORTING
      it_importing    = it_importing
      it_changing_in  = it_changing_in
      iv_increase_call_counter = abap_true
    IMPORTING
      et_exporting    = et_exporting
      et_changing_out = et_changing_out.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~EXPORTS">
   <source>METHOD zif_mocka_mocker_method~exports.
* registers EXPORTING parameters
  DATA lv_parameter_count TYPE i.
  DATA lv_actual_parameter_count TYPE i.
  DATA lr_ref TYPE REF TO data.
  FIELD-SYMBOLS &lt;lv_in&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_to&gt; TYPE any.

  ADD 1 TO lv_parameter_count.
  IF i_p2 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.

  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid    = zcx_mocka=&gt;no_such_method
        interface = mo_mocker-&gt;mv_interface
        method    = mv_method_name.
  ENDIF.
* count &amp; verify importing parameters
  LOOP AT &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WHERE parm_kind = &apos;E&apos;.
    ADD 1 TO lv_actual_parameter_count.
  ENDLOOP.
  IF lv_parameter_count &gt; lv_actual_parameter_count.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid = zcx_mocka=&gt;invalid_parameter_count.
  ENDIF.

* map importing parameters to current method call pattern
  DATA ls_exporting TYPE zif_mocka_mocker_method=&gt;ty_s_name_value_pair.

  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.

  FIELD-SYMBOLS &lt;ls_current_call_pattern&gt; LIKE LINE OF mt_current_method_call_pattern.
  IF mt_current_method_call_pattern IS INITIAL.
    APPEND INITIAL LINE TO mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
  ENDIF.
  LOOP AT mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
    FREE: &lt;ls_current_call_pattern&gt;-exporting.
  ENDLOOP.
  READ TABLE &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WITH KEY parm_kind = &apos;E&apos;.
  IF sy-subrc NE 0.
    DATA lv_interface TYPE abap_abstypename.
    lv_interface =  mo_mocker-&gt;zif_mocka_mocker~get_interface( ).
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid    = zcx_mocka=&gt;no_exporting_parameters
        interface = lv_interface
        method    = mv_method_name.
  ENDIF.
  LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = &apos;E&apos;.
    ADD 1 TO lv_index.
    CASE lv_index.
      WHEN 1.
        GET REFERENCE OF i_p1 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 2.
        GET REFERENCE OF i_p2 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 3.
        GET REFERENCE OF i_p3 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 4.
        GET REFERENCE OF i_p4 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 5.
        GET REFERENCE OF i_p5 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 6.
        GET REFERENCE OF i_p6 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 7.
        GET REFERENCE OF i_p7 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
      WHEN 8.
        GET REFERENCE OF i_p8 INTO lr_ref.
        ls_exporting-value = copy_value( lr_ref ).
    ENDCASE.
    ls_exporting-parameter = &lt;ls_parameter&gt;-name.

    LOOP AT mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
      APPEND ls_exporting TO &lt;ls_current_call_pattern&gt;-exporting.
    ENDLOOP.
  ENDLOOP.

  finalize_current_method_sign( ).
  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~FINALIZE_CURRENT_METHOD_SIGN">
   <source>METHOD ZIF_MOCKA_MOCKER_method~finalize_current_method_sign.
  ro_mocker = finalize_current_method_sign( ).
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~GENERATE_MOCKUP">
   <source>METHOD ZIF_MOCKA_MOCKER_method~generate_mockup.
  ro_mockup = mo_mocker-&gt;ZIF_MOCKA_MOCKER~generate_mockup( ).
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~GET_ALL_RAISES_BY_NAME">
   <source>METHOD ZIF_MOCKA_MOCKER_method~get_all_raises_by_name.
  FIELD-SYMBOLS &lt;ls_pattern&gt; LIKE LINE OF mt_method_call_patterns.
  LOOP AT mt_method_call_patterns ASSIGNING &lt;ls_pattern&gt; WHERE raises_by_name IS NOT INITIAL.
    APPEND &lt;ls_pattern&gt;-raises_by_name TO rt_raises.
  ENDLOOP.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~HAS_BEEN_CALLED_WITH">
   <source>METHOD zif_mocka_mocker_method~has_been_called_with.

  DATA lv_param_kind TYPE c.
  DATA lv_is_importing TYPE abap_bool VALUE abap_true.
  DATA ls_method_call_pattern LIKE LINE OF mt_current_method_call_pattern.
  IF lv_is_importing = abap_true.&quot;toDo: support changing parameters
    lv_param_kind = cl_abap_objectdescr=&gt;importing.
  ELSE.
    lv_param_kind = cl_abap_objectdescr=&gt;changing.
  ENDIF.

  DATA lv_parameter_count TYPE i.
  DATA lv_actual_parameter_count TYPE i.
  DATA lr_ref TYPE REF TO data.

  IF i_p1 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p2 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.

  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY alias_for = mv_method_name.
    IF sy-subrc NE 0.
      RAISE EXCEPTION TYPE zcx_mocka
        EXPORTING
          textid    = zcx_mocka=&gt;no_such_method
          interface = mo_mocker-&gt;mv_interface
          method    = mv_method_name.
    ENDIF.
  ENDIF.
* count &amp; verify importing parameters
  LOOP AT &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WHERE parm_kind = lv_param_kind.
    ADD 1 TO lv_actual_parameter_count.
  ENDLOOP.
  IF lv_parameter_count &gt; lv_actual_parameter_count.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid = zcx_mocka=&gt;invalid_parameter_count.
  ENDIF.

* map importing parameters to current method call pattern
  DATA ls_importing LIKE LINE OF ls_method_call_pattern-importing.&quot;has the same structure as exporting arguments
  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.

  LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = lv_param_kind.
    ADD 1 TO lv_index.
    CASE lv_index.
      WHEN 1.
        GET REFERENCE OF i_p1 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 2.
        GET REFERENCE OF i_p2 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 3.
        GET REFERENCE OF i_p3 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 4.
        GET REFERENCE OF i_p4 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 5.
        GET REFERENCE OF i_p5 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 6.
        GET REFERENCE OF i_p6 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 7.
        GET REFERENCE OF i_p7 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 8.
        GET REFERENCE OF i_p8 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
    ENDCASE.
    ls_importing-parameter = &lt;ls_parameter&gt;-name.
    IF lv_is_importing = abap_true.
      APPEND ls_importing TO ls_method_call_pattern-importing.
    ELSE.
      APPEND ls_importing TO ls_method_call_pattern-changing_in.
    ENDIF.
  ENDLOOP.

  CALL METHOD has_been_called_with
    EXPORTING
      it_importing       = ls_method_call_pattern-importing
      it_changing_in     = ls_method_call_pattern-changing_in
    RECEIVING
      rv_has_been_called = rv_has_been_called.

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~HAS_METHOD_BEEN_CALLED">
   <source>METHOD ZIF_MOCKA_MOCKER_method~has_method_been_called.
  DATA lv_call_count TYPE i.
  CALL METHOD me-&gt;ZIF_MOCKA_MOCKER_method~times_called
    RECEIVING
      rv_times = lv_call_count.
  IF lv_call_count &gt; 0.
    rv_has_been_called = abap_true.
  ELSE.
    rv_has_been_called = abap_false.
  ENDIF.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~HAS_REGISTERED_CALL_PATTERN">
   <source>METHOD ZIF_MOCKA_MOCKER_method~has_registered_call_pattern.
  IF mt_method_call_patterns IS NOT INITIAL.
    rv_has_pattern_registered = abap_true.
  ENDIF.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RAISE">
   <source>METHOD ZIF_MOCKA_MOCKER_method~raise.
  DATA lo_cx_root TYPE REF TO cx_root.
  CALL METHOD me-&gt;resolve_method_output
    EXPORTING
      it_importing   = it_importing
      it_changing_in = it_changing_in
    IMPORTING
      ev_exception   = rv_exception
      eo_cx_root     = lo_cx_root.
  IF lo_cx_root IS NOT INITIAL.
    RAISE EXCEPTION lo_cx_root.
  ENDIF.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RAISES">
   <source>METHOD zif_mocka_mocker_method~raises.
  IF mt_current_method_call_pattern IS INITIAL.
    APPEND INITIAL LINE TO mt_current_method_call_pattern.
  ENDIF.

  FIELD-SYMBOLS &lt;ls_current_call_pattern&gt; LIKE LINE OF mt_current_method_call_pattern.
  LOOP AT mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
    CLEAR: &lt;ls_current_call_pattern&gt;-raises_by_name.
    &lt;ls_current_call_pattern&gt;-raises = io_cx_root.
  ENDLOOP.
  finalize_current_method_sign( ).
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RAISES_BY_NAME">
   <source>METHOD zif_mocka_mocker_method~raises_by_name.
* registers an exception that is specified by a name
  DATA: ls_class_descr TYPE vseoclass,
        ls_seoclskey TYPE seoclskey,
        lv_exception TYPE seoclsname.
  DATA lv_interface TYPE abap_abstypename.
  lv_exception = iv_exception.
  TRANSLATE lv_exception TO UPPER CASE.

  ls_seoclskey-clsname = lv_exception.
  CALL FUNCTION &apos;SEO_CLASS_READ&apos;
    EXPORTING
      clskey = ls_seoclskey
    IMPORTING
      class  = ls_class_descr.
  IF ls_class_descr IS INITIAL.
    lv_interface = mo_mocker-&gt;zif_mocka_mocker~get_interface( ).
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid    = zcx_mocka=&gt;no_such_exception
        interface = lv_interface
        exception = lv_exception
        method    = mv_method_name.
  ENDIF.
  IF ls_class_descr-category NE seoc_category_exception.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid    = zcx_mocka=&gt;invalid_exception
        exception = lv_exception.
  ENDIF.
  IF ls_class_descr-clsabstrct = abap_true.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid    = zcx_mocka=&gt;abstract_exception
        exception = lv_exception.
  ENDIF.

  IF mt_current_method_call_pattern IS INITIAL.
    APPEND INITIAL LINE TO mt_current_method_call_pattern.
  ENDIF.

  FIELD-SYMBOLS &lt;ls_current_call_pattern&gt; LIKE LINE OF mt_current_method_call_pattern.
  LOOP AT mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
    FREE: &lt;ls_current_call_pattern&gt;-raises.
    &lt;ls_current_call_pattern&gt;-raises_by_name = lv_exception.
  ENDLOOP.

  finalize_current_method_sign( ).
  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RETURN">
   <source>METHOD ZIF_MOCKA_MOCKER_method~return.
  CALL METHOD me-&gt;resolve_method_output
    EXPORTING
      it_importing   = it_importing
      it_changing_in = it_changing_in
      iv_increase_call_counter = abap_true
    IMPORTING
*     et_exporting   =
      er_result      = r_result
*     ev_exception   =
    .

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~RETURNS">
   <source>METHOD zif_mocka_mocker_method~returns.
* registers the method&apos;s RETURNING parameter
  TRY.
      me-&gt;zif_mocka_mocker_method~exports( i_return ).
    CATCH zcx_mocka.
      DATA lr_ref TYPE REF TO data.
      FIELD-SYMBOLS: &lt;lv_in&gt; TYPE any, &lt;lv_to&gt; TYPE any.
      GET REFERENCE OF i_return INTO lr_ref.

      ASSIGN lr_ref-&gt;* TO &lt;lv_in&gt;.

      FIELD-SYMBOLS &lt;ls_current_call_pattern&gt; LIKE LINE OF mt_current_method_call_pattern.
      IF mt_current_method_call_pattern IS INITIAL.
        APPEND INITIAL LINE TO mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
      ENDIF.

      LOOP AT mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
        CREATE DATA &lt;ls_current_call_pattern&gt;-returning LIKE &lt;lv_in&gt;.
        ASSIGN &lt;ls_current_call_pattern&gt;-returning-&gt;* TO &lt;lv_to&gt;.
        &lt;lv_to&gt; = &lt;lv_in&gt;.
      ENDLOOP.
  ENDTRY.

  finalize_current_method_sign( ).
  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~TIMES_CALLED">
   <source>METHOD ZIF_MOCKA_MOCKER_method~times_called.
  rv_times = mv_times_called.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~WITH">
   <source>METHOD zif_mocka_mocker_method~with.
  DATA lt_params TYPE abap_parmbind_tab.
  DATA ls_param TYPE abap_parmbind.
  DATA lv_iv_is_importing TYPE abap_bool VALUE abap_true.
  FIELD-SYMBOLS &lt;lv_val&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_val2&gt; TYPE any.

  ls_param-kind = &apos;E&apos;.
  IF i_p1 IS SUPPLIED.
    GET REFERENCE OF i_p1 INTO ls_param-value.
    ls_param-name = &apos;I_P1&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p2 IS SUPPLIED.
    GET REFERENCE OF i_p2 INTO ls_param-value.
    ls_param-name = &apos;I_P2&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    GET REFERENCE OF i_p3 INTO ls_param-value.
    ls_param-name = &apos;I_P3&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    GET REFERENCE OF i_p4 INTO ls_param-value.
    ls_param-name = &apos;I_P4&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    GET REFERENCE OF i_p5 INTO ls_param-value.
    ls_param-name = &apos;I_P5&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    GET REFERENCE OF i_p6 INTO ls_param-value.
    ls_param-name = &apos;I_P6&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    GET REFERENCE OF i_p7 INTO ls_param-value.
    ls_param-name = &apos;I_P7&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    GET REFERENCE OF i_p8 INTO ls_param-value.
    ls_param-name = &apos;I_P8&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.

  ls_param-name = &apos;IV_IS_IMPORTING&apos;.
  GET REFERENCE OF lv_iv_is_importing INTO ls_param-value.
  INSERT ls_param INTO TABLE lt_params.

  CALL METHOD (&apos;WITH_INTERNAL&apos;)
      PARAMETER-TABLE
      lt_params.

  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD~WITH_CHANGING">
   <source>METHOD ZIF_MOCKA_MOCKER_method~with_changing.
  DATA lt_params TYPE abap_parmbind_tab.
  DATA ls_param TYPE abap_parmbind.
  DATA lv_iv_is_importing TYPE abap_bool.
  FIELD-SYMBOLS &lt;lv_val&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_val2&gt; TYPE any.

  ls_param-kind = &apos;E&apos;.
  IF i_p1 IS SUPPLIED.
    GET REFERENCE OF i_p1 INTO ls_param-value.
    ls_param-name = &apos;I_P1&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p2 IS SUPPLIED.
    GET REFERENCE OF i_p2 INTO ls_param-value.
    ls_param-name = &apos;I_P2&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    GET REFERENCE OF i_p3 INTO ls_param-value.
    ls_param-name = &apos;I_P3&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    GET REFERENCE OF i_p4 INTO ls_param-value.
    ls_param-name = &apos;I_P4&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    GET REFERENCE OF i_p5 INTO ls_param-value.
    ls_param-name = &apos;I_P5&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    GET REFERENCE OF i_p6 INTO ls_param-value.
    ls_param-name = &apos;I_P6&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    GET REFERENCE OF i_p7 INTO ls_param-value.
    ls_param-name = &apos;I_P7&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    GET REFERENCE OF i_p8 INTO ls_param-value.
    ls_param-name = &apos;I_P8&apos;.
    INSERT ls_param INTO TABLE lt_params.
  ENDIF.

  ls_param-name = &apos;IV_IS_IMPORTING&apos;.
  GET REFERENCE OF lv_iv_is_importing INTO ls_param-value.
  INSERT ls_param INTO TABLE lt_params.

  CALL METHOD (&apos;WITH_INTERNAL&apos;)
      PARAMETER-TABLE
      lt_params.

  ro_mocker_method = me.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM~INCREASE_TIMES_CALLED">
   <source>METHOD zif_mocka_mocker_method_runtim~increase_times_called.
  increase_call_count( iv_increment ).
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CPDNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM~REGISTER_HAS_BEEN_CALLED_WITH">
   <source>METHOD zif_mocka_mocker_method_runtim~register_has_been_called_with.
  DATA ls_method_call LIKE LINE OF mt_method_calls.
  DATA ls_importing LIKE LINE OF ls_method_call-importing.
  FIELD-SYMBOLS &lt;ls_importing&gt; LIKE LINE OF ls_method_call-importing.
  DATA ls_changing_in LIKE LINE OF ls_method_call-changing_in.
  FIELD-SYMBOLS &lt;ls_changing_in&gt; LIKE LINE OF ls_method_call-changing_in.

  LOOP AT it_importing ASSIGNING &lt;ls_importing&gt;.
    ls_importing-parameter = &lt;ls_importing&gt;-parameter.
    ls_importing-value = copy_value( &lt;ls_importing&gt;-value ).
    APPEND ls_importing TO ls_method_call-importing.
  ENDLOOP.

  LOOP AT it_changing_in ASSIGNING &lt;ls_changing_in&gt;.
    ls_changing_in-parameter = &lt;ls_changing_in&gt;-parameter.
    ls_changing_in-value = copy_value( &lt;ls_changing_in&gt;-value ).
    APPEND ls_changing_in TO ls_method_call-changing_in.
  ENDLOOP.

  APPEND ls_method_call TO mt_method_calls.
ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="CONSTRUCTOR" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="E" DESCRIPT="Vollständiger Komponentenname" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="CONSTRUCTOR" SCONAME="IO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="implementiert eine Erzeuger von Attrappen" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_MOCKA_MOCKER"/>
   <source>METHOD constructor.
  mv_method_name = iv_method_name.
  mo_mocker = io_mocker.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="COPY_VALUE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="COPY_VALUE" SCONAME="IR_REF" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="COPY_VALUE" SCONAME="RR_REF" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD copy_value.
  FIELD-SYMBOLS &lt;lv_in&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_out&gt; TYPE any.

  ASSIGN ir_ref-&gt;* TO &lt;lv_in&gt;.
  CREATE DATA rr_ref LIKE &lt;lv_in&gt;.
  ASSIGN rr_ref-&gt;* TO &lt;lv_out&gt;.
  &lt;lv_out&gt; = &lt;lv_in&gt;.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="FINALIZE_CURRENT_METHOD_SIGN" VERSION="1" LANGU="E" DESCRIPT="internal - finalizes the current method recording" EXPOSURE="1" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="FINALIZE_CURRENT_METHOD_SIGN" SCONAME="RO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="Beschreibt einen Mockup-Erzeuger" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
   <source>METHOD finalize_current_method_sign.
  ro_mocker = mo_mocker.
  CHECK mt_current_method_call_pattern IS NOT INITIAL.
  APPEND LINES OF mt_current_method_call_pattern TO mt_method_call_patterns.
  FREE: mt_current_method_call_pattern.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" VERSION="1" LANGU="E" DESCRIPT="internal - resolve method output parameters" EXPOSURE="1" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="IT_IMPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="RV_HAS_BEEN_CALLED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>METHOD has_been_called_with.
  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.
  FIELD-SYMBOLS &lt;ls_method_call_pattern&gt; TYPE zif_mocka_mocker_method=&gt;ty_s_method_call_pattern.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE mo_mocker-&gt;mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    READ TABLE mo_mocker-&gt;mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY alias_for = mv_method_name.
  ENDIF.
  CHECK &lt;ls_method&gt; IS ASSIGNED.

  DATA ls_importing TYPE zif_mocka_mocker_method=&gt;ty_s_name_value_pair.
  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.
  FIELD-SYMBOLS &lt;lv_val&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_val_importing&gt; TYPE any.
  DATA lv_equals TYPE abap_bool.
  FIELD-SYMBOLS &lt;ls_importing&gt; LIKE LINE OF it_importing.

  LOOP AT mt_method_calls ASSIGNING &lt;ls_method_call_pattern&gt;.
    CLEAR: lv_index.
    lv_equals = abap_true.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = cl_abap_objectdescr=&gt;importing.
*     compare IMPORTING parameters
      READ TABLE it_importing ASSIGNING &lt;ls_importing&gt; WITH KEY parameter = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        READ TABLE &lt;ls_method_call_pattern&gt;-importing INTO ls_importing WITH KEY parameter = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          ASSIGN ls_importing-value-&gt;* TO &lt;lv_val&gt;.
          ASSIGN &lt;ls_importing&gt;-value-&gt;* TO &lt;lv_val_importing&gt;.
          lv_equals = zcl_mocka_value_comparison=&gt;assert_equals( act = &lt;lv_val_importing&gt; exp = &lt;lv_val&gt; ).
        ELSE.
          IF &lt;ls_method_call_pattern&gt;-importing IS NOT INITIAL.
            lv_equals = abap_false.
          ENDIF.
        ENDIF.
      ENDIF.
      IF lv_equals = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF lv_equals = abap_false.
      CONTINUE.
    ENDIF.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = cl_abap_objectdescr=&gt;changing.
*     compare CHANGING parameters
      READ TABLE it_changing_in ASSIGNING &lt;ls_importing&gt; WITH KEY parameter = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        READ TABLE &lt;ls_method_call_pattern&gt;-changing_in INTO ls_importing WITH KEY parameter = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          ASSIGN ls_importing-value-&gt;* TO &lt;lv_val&gt;.
          ASSIGN &lt;ls_importing&gt;-value-&gt;* TO &lt;lv_val_importing&gt;.
          lv_equals = zcl_mocka_value_comparison=&gt;assert_equals( act = &lt;lv_val_importing&gt; exp = &lt;lv_val&gt; ).
        ELSE.
          IF &lt;ls_method_call_pattern&gt;-changing_in IS NOT INITIAL.
            lv_equals = abap_false.
          ENDIF.
        ENDIF.
      ENDIF.
      IF lv_equals = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF lv_equals = abap_false.
      CONTINUE.
    ELSE.
      EXIT.
    ENDIF.
  ENDLOOP.
  rv_has_been_called = lv_equals.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="INCREASE_CALL_COUNT" VERSION="1" LANGU="E" DESCRIPT="internal - increase method call count" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="INCREASE_CALL_COUNT" SCONAME="IV_INCREMENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>METHOD INCREASE_CALL_COUNT.
  ADD iv_increment TO mv_times_called.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" VERSION="1" LANGU="E" DESCRIPT="internal - resolve method output parameters" EXPOSURE="1" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="IT_IMPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="IV_INCREASE_CALL_COUNTER" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="ET_CHANGING_OUT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="ET_EXPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="ER_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="EV_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Objekttypname" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="RESOLVE_METHOD_OUTPUT" SCONAME="EO_CX_ROOT" VERSION="1" LANGU="E" DESCRIPT="Abstrakte Oberklasse aller globalen Exceptions" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="CX_ROOT"/>
   <source>METHOD resolve_method_output.
  CLEAR: et_exporting,
          er_result,
          ev_exception,
          et_changing_out,
          eo_cx_root.

  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.
  FIELD-SYMBOLS &lt;ls_method_call_pattern&gt; TYPE zif_mocka_mocker_method=&gt;ty_s_method_call_pattern.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE mo_mocker-&gt;mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    READ TABLE mo_mocker-&gt;mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY alias_for = mv_method_name.
  ENDIF.
  CHECK &lt;ls_method&gt; IS ASSIGNED.

  DATA ls_importing TYPE zif_mocka_mocker_method=&gt;ty_s_name_value_pair.
  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.
  FIELD-SYMBOLS &lt;lv_val&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_val_importing&gt; TYPE any.
  DATA lv_equals TYPE abap_bool.
  FIELD-SYMBOLS &lt;ls_importing&gt; LIKE LINE OF it_importing.

  LOOP AT mt_method_call_patterns ASSIGNING &lt;ls_method_call_pattern&gt;.
    CLEAR: lv_index.
    lv_equals = abap_true.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = cl_abap_objectdescr=&gt;importing.
*     compare IMPORTING parameters
      READ TABLE it_importing ASSIGNING &lt;ls_importing&gt; WITH KEY parameter = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        READ TABLE &lt;ls_method_call_pattern&gt;-importing INTO ls_importing WITH KEY parameter = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          ASSIGN ls_importing-value-&gt;* TO &lt;lv_val&gt;.
          ASSIGN &lt;ls_importing&gt;-value-&gt;* TO &lt;lv_val_importing&gt;.
          lv_equals = zcl_mocka_value_comparison=&gt;assert_equals( act = &lt;lv_val_importing&gt; exp = &lt;lv_val&gt; ).
        ELSE.
          IF &lt;ls_method_call_pattern&gt;-importing IS NOT INITIAL.
            lv_equals = abap_false.
          ENDIF.
        ENDIF.
      ENDIF.
      IF lv_equals = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF lv_equals = abap_false.
      CONTINUE.
    ENDIF.
    LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = cl_abap_objectdescr=&gt;changing.
*     compare CHANGING parameters
      READ TABLE it_changing_in ASSIGNING &lt;ls_importing&gt; WITH KEY parameter = &lt;ls_parameter&gt;-name.
      IF sy-subrc = 0.
        READ TABLE &lt;ls_method_call_pattern&gt;-changing_in INTO ls_importing WITH KEY parameter = &lt;ls_parameter&gt;-name.
        IF sy-subrc = 0.
          ASSIGN ls_importing-value-&gt;* TO &lt;lv_val&gt;.
          ASSIGN &lt;ls_importing&gt;-value-&gt;* TO &lt;lv_val_importing&gt;.
          lv_equals = zcl_mocka_value_comparison=&gt;assert_equals( act = &lt;lv_val_importing&gt; exp = &lt;lv_val&gt; ).
        ELSE.
          IF &lt;ls_method_call_pattern&gt;-changing_in IS NOT INITIAL.
            lv_equals = abap_false.
          ENDIF.
        ENDIF.
      ENDIF.
      IF lv_equals = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF lv_equals = abap_false.
      CONTINUE.
    ELSE.
      er_result = &lt;ls_method_call_pattern&gt;-returning.
      ev_exception = &lt;ls_method_call_pattern&gt;-raises_by_name.
      eo_cx_root = &lt;ls_method_call_pattern&gt;-raises.
      et_exporting = &lt;ls_method_call_pattern&gt;-exporting.
      et_changing_out = &lt;ls_method_call_pattern&gt;-changing_out.
      IF &lt;ls_method_call_pattern&gt;-times_resolved &gt; 0.
        CONTINUE.&quot;search for another pattern that might fit
      ELSE.
        EXIT.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF &lt;ls_method_call_pattern&gt; IS ASSIGNED AND ( iv_increase_call_counter = abap_true OR ev_exception IS NOT INITIAL OR eo_cx_root IS NOT INITIAL ).
    ADD 1 TO &lt;ls_method_call_pattern&gt;-times_resolved.
  ENDIF.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" VERSION="1" LANGU="E" DESCRIPT="internal - register method call parameters" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="IV_IS_IMPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_METHOD" CMPNAME="WITH_INTERNAL" SCONAME="RO_SELF" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="10 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
   <source>METHOD with_internal.
  DATA lv_param_kind TYPE c.
  IF iv_is_importing = abap_true.
    lv_param_kind = &apos;I&apos;.
  ELSE.
    lv_param_kind = &apos;C&apos;.
  ENDIF.

  DATA lv_parameter_count TYPE i.
  DATA lv_actual_parameter_count TYPE i.
  DATA lr_ref TYPE REF TO data.

  IF i_p1 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p2 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p3 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p4 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p5 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p6 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p7 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.
  IF i_p8 IS SUPPLIED.
    ADD 1 TO lv_parameter_count.
  ENDIF.



  FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
  DATA lo_objdescr TYPE REF TO cl_abap_objectdescr.

  lo_objdescr = mo_mocker-&gt;mo_objectdescr.
  READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY name = mv_method_name.
  IF sy-subrc NE 0.
    READ TABLE lo_objdescr-&gt;methods ASSIGNING &lt;ls_method&gt; WITH KEY alias_for = mv_method_name.
    IF sy-subrc NE 0.
      RAISE EXCEPTION TYPE zcx_mocka
        EXPORTING
          textid    = zcx_mocka=&gt;no_such_method
          interface = mo_mocker-&gt;mv_interface
          method    = mv_method_name.
    ENDIF.
  ENDIF.
* count &amp; verify importing parameters
  LOOP AT &lt;ls_method&gt;-parameters TRANSPORTING NO FIELDS WHERE parm_kind = lv_param_kind.
    ADD 1 TO lv_actual_parameter_count.
  ENDLOOP.
  IF lv_parameter_count &gt; lv_actual_parameter_count.
    RAISE EXCEPTION TYPE zcx_mocka
      EXPORTING
        textid = zcx_mocka=&gt;invalid_parameter_count.
  ENDIF.

* map importing parameters to current method call pattern
  DATA ls_importing TYPE zif_mocka_mocker_method=&gt;ty_s_name_value_pair.&quot;has the same structure as exporting arguments
  FIELD-SYMBOLS: &lt;ls_parameter&gt; LIKE LINE OF &lt;ls_method&gt;-parameters.
  DATA lv_index TYPE i.
  DATA lv_comp TYPE string.

  FIELD-SYMBOLS &lt;ls_current_call_pattern&gt; LIKE LINE OF mt_current_method_call_pattern.
  DATA lv_lines TYPE i.
  DESCRIBE TABLE mt_current_method_call_pattern LINES lv_lines.

  IF lv_lines &gt; 0.
    READ TABLE mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt; INDEX lv_lines.
    IF iv_is_importing = abap_true AND &lt;ls_current_call_pattern&gt;-importing IS NOT INITIAL.
      APPEND INITIAL LINE TO mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
    ENDIF.
    IF iv_is_importing = abap_false AND &lt;ls_current_call_pattern&gt;-changing_in IS NOT INITIAL.
      APPEND INITIAL LINE TO mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
    ENDIF.
    IF &lt;ls_current_call_pattern&gt;-changing_out IS NOT INITIAL
      OR &lt;ls_current_call_pattern&gt;-exporting IS NOT INITIAL
      OR &lt;ls_current_call_pattern&gt;-returning IS NOT INITIAL
      OR &lt;ls_current_call_pattern&gt;-raises IS NOT INITIAL
      OR &lt;ls_current_call_pattern&gt;-raises_by_name IS NOT INITIAL.
      APPEND INITIAL LINE TO mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
    ENDIF.
  ELSE.
    APPEND INITIAL LINE TO mt_current_method_call_pattern ASSIGNING &lt;ls_current_call_pattern&gt;.
  ENDIF.

  LOOP AT &lt;ls_method&gt;-parameters ASSIGNING &lt;ls_parameter&gt; WHERE parm_kind = lv_param_kind.
    ADD 1 TO lv_index.
    CASE lv_index.
      WHEN 1.
        GET REFERENCE OF i_p1 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 2.
        GET REFERENCE OF i_p2 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 3.
        GET REFERENCE OF i_p3 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 4.
        GET REFERENCE OF i_p4 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 5.
        GET REFERENCE OF i_p5 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 6.
        GET REFERENCE OF i_p6 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 7.
        GET REFERENCE OF i_p7 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
      WHEN 8.
        GET REFERENCE OF i_p8 INTO lr_ref.
        ls_importing-value = copy_value( lr_ref ).
    ENDCASE.
    ls_importing-parameter = &lt;ls_parameter&gt;-name.

    IF iv_is_importing = abap_true.
      APPEND ls_importing TO &lt;ls_current_call_pattern&gt;-importing.
    ELSE.
      APPEND ls_importing TO &lt;ls_current_call_pattern&gt;-changing_in.
    ENDIF.
  ENDLOOP.

  ro_self = me.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" VERSION="1" LANGU="D" DESCRIPT="verifies if two values are equal" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&amp;---------------------------------------------------------------------*
*&amp;       Class Lcl_Assert
*&amp;---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*
Type-Pools: Abap.</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class
define ASSERT_WRONG_STATE.
 assert CONDITION 0 = 1.
end-of-definition.</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <textPool>
   <language SPRAS="E">
    <textElement ID="I" KEY="100" ENTRY="{Invalid Data Reference}" LENGTH="30 "/>
    <textElement ID="I" KEY="101" ENTRY="{Invalid Object Reference}" LENGTH="30 "/>
    <textElement ID="I" KEY="102" ENTRY="{Nesting Too Deep}" LENGTH="30 "/>
   </language>
  </textPool>
  <classDocumentation OBJECT="ZCL_MOCKA_VALUE_COMPARISON">
   <language SPRAS="E">
    <textLine TDFORMAT="U1" TDLINE="&amp;FUNCTIONALITY&amp;"/>
    <textLine TDFORMAT="AS" TDLINE="The class CL_ABAP_UNIT_ASSERT contains the following static methods for"/>
    <textLine TDLINE="the verification of test expectations within"/>
    <textLine TDFORMAT="=" TDLINE=" &lt;DS:ABEN.ABAP_UNIT_GLOSRY&gt;ABAP Unit&lt;/&gt; test methods:"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_EQUALS&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure the equality of two data objects. Please note that the arguments"/>
    <textLine TDLINE="are passed by reference. Objects are tested for identity only. Please"/>
    <textLine TDLINE="stick to the method ASSERT_THAT and the interface"/>
    <textLine TDFORMAT="=" TDLINE="&lt;DS:IF.IF_CONSTRAINT&gt;IF_CONSTRAINT&lt;/&gt; for custom assertions."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_EQUALS_FLOAT&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure the equality of two decimal floats with a relative tolerance."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_DIFFERS&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure the value of two data objects not to be equal."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_BOUND&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure whether the reference of a reference variable is valid."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_NOT_BOUND&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure whether the reference of a reference variable is invalid."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_INITIAL&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that a data object has its initial value."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_NOT_INITIAL&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that a data object does not have its initial value."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_SUBRC&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Requests specific value of SY-SUBRC."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_TABLE_CONTAINS &lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that a internal table contains a certain line."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_TEXT_MATCHES &lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that a text matches to a"/>
    <textLine TDFORMAT="=" TDLINE=" &lt;DS:ABEN.REGEX_SYNTAX&gt;regular expression&lt;/&gt;."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ASSERT_THAT &lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Ensure that the actual value adheres to a given"/>
    <textLine TDFORMAT="=" TDLINE="&lt;DS:IF.IF_CONSTRAINT&gt;Constraint&lt;/&gt;."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;FAIL&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Terminate the test with an unconditional error."/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ABORT&lt;/&gt;"/>
    <textLine TDFORMAT="/" TDLINE="Cancel the test due to a missing prerequisite."/>
    <textLine TDFORMAT="AS" TDLINE="All the methods have the optional importing parameters MSG, LEVEL, and"/>
    <textLine TDLINE="QUIT, which always have the same meaning:"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;MSG&lt;/&gt; (Type: CSEQUENCE)"/>
    <textLine TDFORMAT="/" TDLINE="Contains a more detailed description of the error (if applicable)"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;LEVEL&lt;/&gt; (Type: AUNIT_LEVEL)"/>
    <textLine TDFORMAT="/" TDLINE="Indicates the severity of the error; the following values are possible:"/>
    <textLine TDFORMAT="B2" TDLINE="TOLERABLE - Minor error (may be tolerable)"/>
    <textLine TDFORMAT="B2" TDLINE="CRITICAL - Critical error (default value)"/>
    <textLine TDFORMAT="B2" TDLINE="FATAL    - Fatal error"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;QUIT&lt;/&gt; (Type: AUNIT_FLOWCTRL)"/>
    <textLine TDFORMAT="/" TDLINE="Determines the flow control in the case of an error. The following"/>
    <textLine TDLINE="values can be passed:"/>
    <textLine TDFORMAT="B2" TDLINE="NO - No termination in the case of an error; processing of the current"/>
    <textLine TDLINE="method continues after the relevant method is called"/>
    <textLine TDFORMAT="B2" TDLINE="METHOD  - The currently processed test method is terminated (default"/>
    <textLine TDLINE="value)"/>
    <textLine TDFORMAT="B2" TDLINE="CLASS   - The currently processed test class is terminated"/>
    <textLine TDFORMAT="B2" TDLINE="PROGRAM - The test of the currently processed main program is"/>
    <textLine TDLINE="terminated: The current test class is terminated and all other test"/>
    <textLine TDLINE="classes in the program are ignored."/>
    <textLine TDFORMAT="AS" TDLINE="All the assert methods have the following mandatory importing parameter:"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;ACT&lt;/&gt; (Type: Any)"/>
    <textLine TDFORMAT="/" TDLINE="The object to be verified"/>
    <textLine TDFORMAT="AS" TDLINE="The comparing method ASSERT_EQUALS additionally requires a parameter for"/>
    <textLine TDLINE="the expectation:"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;EXP&lt;/&gt; (Type: Any)"/>
    <textLine TDFORMAT="/" TDLINE="The identically expected object"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;ZH&gt;TOL&lt;/&gt; (Type: f)"/>
    <textLine TDFORMAT="/" TDLINE="Allows you to compare floating point numbers for the passed tolerance"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;FURTHER_SOURCES_OF_INF&amp;"/>
    <textLine TDFORMAT="B1" TDLINE="&lt;DS:KENO.3F7182087A5E002FE10000000A1148F9&gt;Knowledge Warehouse&lt;/&gt;"/>
    <textLine TDFORMAT="B1" TDLINE="Package SABP_UNIT_SAMPLE"/>
   </language>
  </classDocumentation>
  <typeUsage CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <typeClasDef CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" TYPEGROUP="CL_AUNIT_ASSERT" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="RTOL_MIN" VERSION="1" LANGU="D" DESCRIPT="Minimum Tolerance for comparsion type F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTVALUE="&apos;1.E-15&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="F" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="ASSERT_EQUALS" VERSION="1" LANGU="D" DESCRIPT="Ensure Equality of Two Data Objects" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="ASSERT_EQUALS" SCONAME="EXP" VERSION="1" LANGU="D" DESCRIPT="Data Object with Expected Type" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="ASSERT_EQUALS" SCONAME="ACT" VERSION="1" LANGU="D" DESCRIPT="Data Object with Current Value" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_MOCKA_VALUE_COMPARISON" CMPNAME="ASSERT_EQUALS" SCONAME="RV_EQUALS" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>METHOD assert_equals.
  DATA lo_type TYPE REF TO cl_abap_typedescr.
  rv_equals = abap_true.
  TRY.
      IF exp EQ act.
        rv_equals = abap_true.
      ELSE.
        rv_equals = abap_false.
      ENDIF.
    CATCH cx_root.
      rv_equals = abap_false.
  ENDTRY.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_MOCKA" VERSION="1" LANGU="D" DESCRIPT="Root exception class of mockA" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" MSG_ID="ZMOCKA_EXC_MOCK" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_NO_CHECK">
  <implementing CLSNAME="ZCX_MOCKA" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCX_MOCKA" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="ABSTRACT_EXCEPTION" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="22 " SRCCOLUMN1="4 " SRCROW2="29 " SRCCOLUMN2="28 " LOCKED="X" TYPESRC_LENG="316 " TYPESRC="begin of ABSTRACT_EXCEPTION,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;008&apos;,
      attr1 type scx_attrname value &apos;EXCEPTION&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of ABSTRACT_EXCEPTION
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="ATTRIBUTE" VERSION="1" LANGU="D" DESCRIPT="Full Component Name" EXPOSURE="2" STATE="1" EDITORDER="16 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCPDNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="EXCEPTION" VERSION="1" LANGU="D" DESCRIPT="Object Type Name" EXPOSURE="2" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCLSNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="GENERIC_TEXT" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="INTERFACE" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="INVALID_EXCEPTION" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="40 " SRCCOLUMN1="4 " SRCROW2="47 " SRCCOLUMN2="27 " LOCKED="X" TYPESRC_LENG="314 " TYPESRC="begin of INVALID_EXCEPTION,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;007&apos;,
      attr1 type scx_attrname value &apos;EXCEPTION&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of INVALID_EXCEPTION
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="INVALID_PARAMETER_COUNT" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="49 " SRCCOLUMN1="4 " SRCROW2="56 " SRCCOLUMN2="33 " LOCKED="X" TYPESRC_LENG="317 " TYPESRC="begin of INVALID_PARAMETER_COUNT,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;001&apos;,
      attr1 type scx_attrname value &apos;&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of INVALID_PARAMETER_COUNT
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="METHOD" VERSION="1" LANGU="D" DESCRIPT="Full Component Name" EXPOSURE="2" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCPDNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_CHANGING_PARAMETERS" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="31 " SRCCOLUMN1="4 " SRCROW2="38 " SRCCOLUMN2="32 " LOCKED="X" TYPESRC_LENG="330 " TYPESRC="begin of NO_CHANGING_PARAMETERS,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;009&apos;,
      attr1 type scx_attrname value &apos;METHOD&apos;,
      attr2 type scx_attrname value &apos;INTERFACE&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_CHANGING_PARAMETERS
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_EXPORTING_PARAMETERS" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="76 " SRCCOLUMN1="4 " SRCROW2="83 " SRCCOLUMN2="33 " LOCKED="X" TYPESRC_LENG="332 " TYPESRC="begin of NO_EXPORTING_PARAMETERS,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;004&apos;,
      attr1 type scx_attrname value &apos;METHOD&apos;,
      attr2 type scx_attrname value &apos;INTERFACE&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_EXPORTING_PARAMETERS
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_RETURNING_PARAMETERS" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="67 " SRCCOLUMN1="4 " SRCROW2="74 " SRCCOLUMN2="33 " LOCKED="X" TYPESRC_LENG="332 " TYPESRC="begin of NO_RETURNING_PARAMETERS,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;005&apos;,
      attr1 type scx_attrname value &apos;METHOD&apos;,
      attr2 type scx_attrname value &apos;INTERFACE&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_RETURNING_PARAMETERS
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_SUCH_ATTRIBUTE" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="17 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="112 " SRCCOLUMN1="4 " SRCROW2="119 " SRCCOLUMN2="27 " LOCKED="X" TYPESRC_LENG="323 " TYPESRC="begin of NO_SUCH_ATTRIBUTE,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;011&apos;,
      attr1 type scx_attrname value &apos;ATTRIBUTE&apos;,
      attr2 type scx_attrname value &apos;INTERFACE&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_SUCH_ATTRIBUTE
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_SUCH_EXCEPTION" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="58 " SRCCOLUMN1="4 " SRCROW2="65 " SRCCOLUMN2="27 " LOCKED="X" TYPESRC_LENG="329 " TYPESRC="begin of NO_SUCH_EXCEPTION,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;006&apos;,
      attr1 type scx_attrname value &apos;EXCEPTION&apos;,
      attr2 type scx_attrname value &apos;METHOD&apos;,
      attr3 type scx_attrname value &apos;INTERFACE&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_SUCH_EXCEPTION
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_SUCH_INTERFACE" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="94 " SRCCOLUMN1="4 " SRCROW2="101 " SRCCOLUMN2="27 " LOCKED="X" TYPESRC_LENG="314 " TYPESRC="begin of NO_SUCH_INTERFACE,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;002&apos;,
      attr1 type scx_attrname value &apos;INTERFACE&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_SUCH_INTERFACE
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="NO_SUCH_METHOD" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="85 " SRCCOLUMN1="4 " SRCROW2="92 " SRCCOLUMN2="24 " LOCKED="X" TYPESRC_LENG="314 " TYPESRC="begin of NO_SUCH_METHOD,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;003&apos;,
      attr1 type scx_attrname value &apos;METHOD&apos;,
      attr2 type scx_attrname value &apos;INTERFACE&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of NO_SUCH_METHOD
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="UNIT_TEST_EXEC_NOT_ALLOWED" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="11 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="103 " SRCCOLUMN1="4 " SRCROW2="110 " SRCCOLUMN2="36 " LOCKED="X" TYPESRC_LENG="323 " TYPESRC="begin of UNIT_TEST_EXEC_NOT_ALLOWED,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;010&apos;,
      attr1 type scx_attrname value &apos;&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of UNIT_TEST_EXEC_NOT_ALLOWED
"/>
  <attribute CLSNAME="ZCX_MOCKA" CMPNAME="ZCX_MOCKA" VERSION="1" LANGU="D" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="20 " SRCCOLUMN2="19 " LOCKED="X" TYPESRC_LENG="301 " TYPESRC="begin of ZCX_MOCKA,
      msgid type symsgid value &apos;ZMOCKA_EXC_MOCK&apos;,
      msgno type symsgno value &apos;000&apos;,
      attr1 type scx_attrname value &apos;GENERIC_TEXT&apos;,
      attr2 type scx_attrname value &apos;&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of ZCX_MOCKA
"/>
  <inheritance CLSNAME="ZCX_MOCKA" REFCLSNAME="CX_NO_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" VERSION="1" LANGU="D" DESCRIPT="Sample-class for unit tests (Mocking-Framework)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <textPool>
   <language SPRAS="E"/>
  </textPool>
  <attribute CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="MO_ALERT_PROCESSOR" VERSION="1" LANGU="D" DESCRIPT="Mocking Framework Example: Alert-Prozessor" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="MO_IS_IN_TIME_ACCESS" VERSION="1" LANGU="D" DESCRIPT="Beispiel-Interface für Mocking-Framework Test" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_MOCKA_IS_IN_TIME_INFO" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="CONSTRUCTOR" SCONAME="IO_ALERT_PROCESSOR" VERSION="1" LANGU="E" DESCRIPT="Example for  Alert Processor" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_MOCKA_FLIGHT_ALERT_PROCESS"/>
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="CONSTRUCTOR" SCONAME="IO_IN_TIME_ACCESS" VERSION="1" LANGU="E" DESCRIPT="Example-Interface for test of Mocking-Framework" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_MOCKA_IS_IN_TIME_INFO"/>
   <source>METHOD constructor.
  mo_alert_processor = io_alert_processor.
  mo_is_in_time_access = io_in_time_access.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="OBSERVE_FLIGHT" VERSION="1" LANGU="E" DESCRIPT="checks a flight" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="OBSERVE_FLIGHT" SCONAME="IV_CARRID" VERSION="1" LANGU="E" DESCRIPT="Carrier name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="OBSERVE_FLIGHT" SCONAME="IV_CONNID" VERSION="1" LANGU="E" DESCRIPT="Flight code" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZCL_MOCKA_FLIGHT_OBSERVER" CMPNAME="OBSERVE_FLIGHT" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" DESCRIPT="flight date" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <source>METHOD observe_flight.
  DATA lv_delay_minutes TYPE i.
  lv_delay_minutes = mo_is_in_time_access-&gt;get_delay(
    iv_carrid = iv_carrid
    iv_connid = iv_connid
    iv_fldate = iv_fldate
  ).
  IF lv_delay_minutes &gt; 60.
    mo_alert_processor-&gt;alert_delay(
      iv_carrid = iv_carrid
      iv_connid = iv_connid
      iv_fldate = iv_fldate ).
  ENDIF.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" VERSION="1" LANGU="D" DESCRIPT="implements a mocked attribute" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <implementing CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" REFCLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <forwardDeclaration>SEOS</forwardDeclaration>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="MO_MOCKER" VERSION="1" LANGU="D" DESCRIPT="describes a creator of mock objects" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="MR_VALUE" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="MV_ATTRIBUTE" VERSION="1" LANGU="D" DESCRIPT="Full Component Name" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCPDNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="MV_IS_SPECIFIED" VERSION="1" LANGU="D" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CPDNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE~IS_VALUE_SPECIFIED">
   <source>METHOD zif_mocka_mocker_attribute~is_value_specified.
  rv_is_value_specified = mv_is_specified.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CPDNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE~RETURN">
   <source>METHOD zif_mocka_mocker_attribute~return.
  r_result = mr_value.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CPDNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE~RETURNS">
   <source>METHOD zif_mocka_mocker_attribute~returns.
  DATA lr_value TYPE REF TO data.
  GET REFERENCE OF i_return INTO lr_value.
  mr_value = copy_value( lr_value ).
  mv_is_specified = abap_true.
  ro_mocker = mo_mocker.
ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="CONSTRUCTOR" SCONAME="IV_ATTRIBUTE" VERSION="1" LANGU="E" DESCRIPT="Full Component Name" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="CONSTRUCTOR" SCONAME="IO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="describes a creator of mock objects" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
   <source>METHOD constructor.
  mv_attribute = iv_attribute.
  mo_mocker = io_mocker.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="COPY_VALUE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="COPY_VALUE" SCONAME="IR_REF" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZCL_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="COPY_VALUE" SCONAME="RR_REF" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>METHOD COPY_VALUE.
  FIELD-SYMBOLS &lt;lv_in&gt; TYPE any.
  FIELD-SYMBOLS &lt;lv_out&gt; TYPE any.

  ASSIGN ir_ref-&gt;* TO &lt;lv_in&gt;.
  CREATE DATA rr_ref LIKE &lt;lv_in&gt;.
  ASSIGN rr_ref-&gt;* TO &lt;lv_out&gt;.
  &lt;lv_out&gt; = &lt;lv_in&gt;.
ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_MOCKA_IN_TIME_EXCEPTION" VERSION="1" LANGU="D" DESCRIPT="Sample-Exception class for unit tests (Mocking-Framework)" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_NO_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_MOCKA_IN_TIME_EXCEPTION" REFCLSNAME="CX_NO_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <INTF CLSNAME="ZIF_MOCKA_MOCKER" VERSION="1" LANGU="E" DESCRIPT="describes a creator of mock objects" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <types CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="TY_S_METHOD_MOCKS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="7 " SRCCOLUMN1="4 " SRCROW2="7 " SRCCOLUMN2="136 " TYPESRC_LENG="133 " TYPESRC="BEGIN OF TY_S_METHOD_MOCKS,  method_name TYPE SEOCPDNAME,  method_mock TYPE REF TO ZIF_MOCKA_MOCKER_METHOD,  END OF TY_S_METHOD_MOCKS"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="TY_T_METHOD_MOCKS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="52 " TYPESRC_LENG="49 " TYPESRC="TY_T_method_mocks type TABLE OF ty_s_method_mocks"/>
  <typeUsage CLSNAME="ZIF_MOCKA_MOCKER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="ATTRIBUTE" VERSION="1" LANGU="E" DESCRIPT="specifies the to-be-mocked attribute" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="ATTRIBUTE" SCONAME="IV_ATTRIBUTE" VERSION="1" LANGU="E" DESCRIPT="Full Component Name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="ATTRIBUTE" SCONAME="RO_ATTRIBUTE" VERSION="1" LANGU="E" DESCRIPT="describes an attribute which is to be mocked" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_ATTRIBUTE"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="GENERATE_MOCKUP" VERSION="1" LANGU="E" DESCRIPT="generates the mock object" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="GENERATE_MOCKUP" SCONAME="RO_MOCKUP" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="GET_INTERFACE" VERSION="1" LANGU="E" DESCRIPT="get the mock object&apos;s interface" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="GET_INTERFACE" SCONAME="RV_INTERFACE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_ANY_METHOD_BEEN_CALLED" VERSION="1" LANGU="E" DESCRIPT="has any method been called?" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_ANY_METHOD_BEEN_CALLED" SCONAME="RV_HAS_BEEN_CALLED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_METHOD_BEEN_CALLED" VERSION="1" LANGU="E" DESCRIPT="has the method been called?" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_METHOD_BEEN_CALLED" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="E" DESCRIPT="Vollständiger Komponentenname" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="HAS_METHOD_BEEN_CALLED" SCONAME="RV_HAS_BEEN_CALLED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD" VERSION="1" LANGU="E" DESCRIPT="specifies the to-be-mocked method" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="E" DESCRIPT="Vollständiger Komponentenname" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD" SCONAME="RO_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD_CALL_COUNT" VERSION="1" LANGU="E" DESCRIPT="how often has the method been called?" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD_CALL_COUNT" SCONAME="IV_METHOD_NAME" VERSION="1" LANGU="E" DESCRIPT="Vollständiger Komponentenname" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDNAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="METHOD_CALL_COUNT" SCONAME="RV_CALL_COUNT" VERSION="1" LANGU="E" DESCRIPT="Natürliche Zahl" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="INT4"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="MOCK" VERSION="1" LANGU="E" DESCRIPT="creates a new mocker-instance" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="MOCK" SCONAME="IV_INTERFACE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="MOCK" SCONAME="RO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="Beschreibt einen Mock-Erzeuger" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="registers super-constructor parameters - IMPORTING" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER" CMPNAME="PASS_TO_SUPER_CONSTRUCTOR" SCONAME="RO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_MOCKA_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="describes a method which is to be mocked" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_T_CLASS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="1" TYPE="SWF_CLASSES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_S_NAME_VALUE_PAIR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="8 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="115 " TYPESRC_LENG="113 " TYPESRC="BEGIN OF ty_s_name_value_pair,  parameter TYPE seosconame,  value TYPE REF TO data,  END OF ty_s_name_value_pair
"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_T_NAME_VALUE_PAIR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="86 " TYPESRC_LENG="84 " TYPESRC="ty_t_name_value_pair TYPE STANDARD TABLE OF ty_s_name_value_pair WITH KEY parameter
"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_S_METHOD_CALL_PATTERN" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="4 " SRCROW2="13 " SRCCOLUMN2="131 " TYPESRC_LENG="384 " TYPESRC="BEGIN OF ty_s_method_call_pattern,        importing TYPE ty_t_name_value_pair,        changing_in TYPE ty_t_name_value_pair,        changing_out TYPE ty_t_name_value_pair,        exporting TYPE ty_t_name_value_pair,        returning TYPE REF TO data,
   raises TYPE REF TO cx_root,        raises_by_name TYPE seoclsname,        times_resolved TYPE i,  END OF ty_s_method_call_pattern
"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TY_T_METHOD_CALL_PATTERN" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="15 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="66 " TYPESRC_LENG="64 " TYPESRC="ty_t_method_call_pattern TYPE TABLE OF ty_s_method_call_pattern
"/>
  <typeUsage CLSNAME="ZIF_MOCKA_MOCKER_METHOD" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" VERSION="1" LANGU="E" DESCRIPT="registers importing/returning parameters - CHANGING" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="CHANGES" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" VERSION="1" LANGU="E" DESCRIPT="get EXPORTING parameters based on call pattern" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" SCONAME="IT_IMPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" SCONAME="ET_EXPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORT" SCONAME="ET_CHANGING_OUT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" VERSION="1" LANGU="E" DESCRIPT="registers returning parameters - EXPORTING" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="EXPORTS" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="FINALIZE_CURRENT_METHOD_SIGN" VERSION="1" LANGU="E" DESCRIPT="finalizes the current method recording" EXPOSURE="2" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="FINALIZE_CURRENT_METHOD_SIGN" SCONAME="RO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="Beschreibt einen Mockup-Erzeuger" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="GENERATE_MOCKUP" VERSION="1" LANGU="E" DESCRIPT="generates the mock object" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="GENERATE_MOCKUP" SCONAME="RO_MOCKUP" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="GET_ALL_RAISES_BY_NAME" VERSION="1" LANGU="E" DESCRIPT="get all registered exceptions" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="GET_ALL_RAISES_BY_NAME" SCONAME="RT_RAISES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_CLASS"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" VERSION="1" LANGU="E" DESCRIPT="has been called with the specified IMPORTING parameters?" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_BEEN_CALLED_WITH" SCONAME="RV_HAS_BEEN_CALLED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_METHOD_BEEN_CALLED" VERSION="1" LANGU="E" DESCRIPT="has the method been called?" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_METHOD_BEEN_CALLED" SCONAME="RV_HAS_BEEN_CALLED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_REGISTERED_CALL_PATTERN" VERSION="1" LANGU="E" DESCRIPT="has the method registered call patterns?" EXPOSURE="2" STATE="1" EDITORDER="17 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="HAS_REGISTERED_CALL_PATTERN" SCONAME="RV_HAS_PATTERN_REGISTERED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" VERSION="1" LANGU="E" DESCRIPT="get the exception, based on call pattern" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" SCONAME="IT_IMPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" SCONAME="RV_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Objekttypname" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <exception CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISE" SCONAME="CX_STATIC_CHECK" VERSION="1" LANGU="E" DESCRIPT="Ausnahmen mit statischer und dynamischer Prüfung von RAISING" MTDTYPE="0" EDITORDER="1 "/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES" VERSION="1" LANGU="E" DESCRIPT="register an exception by object" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES" SCONAME="IO_CX_ROOT" VERSION="1" LANGU="E" DESCRIPT="Abstrakte Oberklasse aller globalen Exceptions" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CX_ROOT"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES_BY_NAME" VERSION="1" LANGU="E" DESCRIPT="register an exception by its name" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES_BY_NAME" SCONAME="IV_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Objekttypname" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSNAME"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RAISES_BY_NAME" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURN" VERSION="1" LANGU="E" DESCRIPT="get RETURNING parameters based on call pattern" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURN" SCONAME="IT_IMPORTING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURN" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_T_NAME_VALUE_PAIR" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURN" SCONAME="R_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURNS" VERSION="1" LANGU="E" DESCRIPT="registers returning parameter - RETURNING" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURNS" SCONAME="I_RETURN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="RETURNS" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TIMES_CALLED" VERSION="1" LANGU="E" DESCRIPT="get the method&apos;s call count" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="TIMES_CALLED" SCONAME="RV_TIMES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" VERSION="1" LANGU="E" DESCRIPT="registers importing parameters - IMPORTING" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" VERSION="1" LANGU="E" DESCRIPT="registers importing parameters - CHANGING" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P1" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P2" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P3" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P4" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P5" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P6" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P7" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="I_P8" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD" CMPNAME="WITH_CHANGING" SCONAME="RO_MOCKER_METHOD" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER_METHOD"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" VERSION="1" LANGU="E" DESCRIPT="Mocking Framework example: Alert-Processor" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <method CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" VERSION="1" LANGU="E" DESCRIPT="Alert auslösen wegen einer Verspätung auslösen" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" SCONAME="IV_CARRID" VERSION="1" LANGU="E" DESCRIPT="Kurzbezeichnung der Fluggesellschaft" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" SCONAME="IV_CONNID" VERSION="1" LANGU="E" DESCRIPT="Code der Einzelflugverbindung" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" DESCRIPT="Flugdatum" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <parameter CLSNAME="ZIF_MOCKA_FLIGHT_ALERT_PROCESS" CMPNAME="ALERT_DELAY" SCONAME="RV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" VERSION="1" LANGU="E" DESCRIPT="Sample-Interface for Mocking-Framework Test" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <attribute CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GC_NAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="IV_CARRID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="IV_CONNID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="EV_DELAY" VERSION="1" LANGU="E" DESCRIPT="Delay in Minutes" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH" SCONAME="EV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH_BY_OPTIONAL_PARAM" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH_BY_OPTIONAL_PARAM" SCONAME="IV_CARRID" VERSION="1" LANGU="E" DESCRIPT="Airline Code" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID" PARVALUE="&apos;LH&apos;"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH_BY_OPTIONAL_PARAM" SCONAME="IV_CONNID" VERSION="1" LANGU="E" DESCRIPT="Flight Connection Number" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID" PARVALUE="402"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH_BY_OPTIONAL_PARAM" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" DESCRIPT="Flight date" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE" PARVALUE="&apos;20121124&apos;"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH_BY_OPTIONAL_PARAM" SCONAME="EV_DELAY" VERSION="1" LANGU="E" DESCRIPT="Delay in Minutes" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BOTH_BY_OPTIONAL_PARAM" SCONAME="EV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" SCONAME="IV_CARRID" VERSION="1" LANGU="E" DESCRIPT="Kurzbezeichnung der Fluggesellschaft" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID" PARVALUE="&apos;LH&apos;"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" SCONAME="IV_CONNID" VERSION="1" LANGU="E" DESCRIPT="Code der Einzelflugverbindung" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID" PARVALUE="402"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" DESCRIPT="Flugdatum" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE" PARVALUE="&apos;20121124&apos;"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_BY_OPTIONAL_PARAMS" SCONAME="RV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" SCONAME="IV_CARRID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" SCONAME="IV_CONNID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="GET_DELAY" SCONAME="RV_DELAY" VERSION="1" LANGU="E" DESCRIPT="Delay in Minutes" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="INT4"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" SCONAME="IV_CARRID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" SCONAME="IV_CONNID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" SCONAME="IV_FLDATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME" SCONAME="RV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" SCONAME="IV_CARRID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CARR_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" SCONAME="IV_CONNID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="S_CONN_ID"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" SCONAME="EV_IS_IN_TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <parameter CLSNAME="ZIF_MOCKA_IS_IN_TIME_INFO" CMPNAME="IS_IN_TIME_BY_CHANGING_PARAM" SCONAME="CV_FLDATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="S_DATE"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM" VERSION="1" LANGU="D" DESCRIPT="describes the access to a method&apos;s runtime information" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM" CMPNAME="INCREASE_TIMES_CALLED" VERSION="1" LANGU="D" DESCRIPT="increase method&apos;s call count" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM" CMPNAME="INCREASE_TIMES_CALLED" SCONAME="IV_INCREMENT" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="1"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM" CMPNAME="REGISTER_HAS_BEEN_CALLED_WITH" VERSION="1" LANGU="D" DESCRIPT="registers actually passed IMPORTING parameters" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM" CMPNAME="REGISTER_HAS_BEEN_CALLED_WITH" SCONAME="IT_IMPORTING" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_METHOD_RUNTIM" CMPNAME="REGISTER_HAS_BEEN_CALLED_WITH" SCONAME="IT_CHANGING_IN" VERSION="1" LANGU="D" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZIF_MOCKA_MOCKER_METHOD=&gt;TY_T_NAME_VALUE_PAIR"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" VERSION="1" LANGU="E" DESCRIPT="describes an attribute which is to be mocked" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <types CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="TY_T_CLASS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="1" TYPE="SWF_CLASSES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="TY_S_NAME_VALUE_PAIR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="115 " TYPESRC_LENG="112 " TYPESRC="BEGIN OF ty_s_name_value_pair,  parameter TYPE seosconame,  value TYPE REF TO data,  END OF ty_s_name_value_pair"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="TY_T_NAME_VALUE_PAIR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="86 " TYPESRC_LENG="83 " TYPESRC="ty_t_name_value_pair TYPE STANDARD TABLE OF ty_s_name_value_pair WITH KEY parameter"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="TY_S_METHOD_CALL_PATTERN" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="14 " SRCCOLUMN2="131 " TYPESRC_LENG="387 " TYPESRC="BEGIN OF ty_s_method_call_pattern,        importing TYPE ty_t_name_value_pair,        changing_in TYPE ty_t_name_value_pair,        changing_out TYPE ty_t_name_value_pair,        exporting TYPE ty_t_name_value_pair,        returning TYPE REF TO data,        raises TYPE REF TO cx_root,        raises_by_name TYPE seoclsname,        times_resolved TYPE i,  END OF ty_s_method_call_pattern"/>
  <types CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="TY_T_METHOD_CALL_PATTERN" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="16 " SRCCOLUMN1="4 " SRCROW2="16 " SRCCOLUMN2="66 " TYPESRC_LENG="63 " TYPESRC="ty_t_method_call_pattern TYPE TABLE OF ty_s_method_call_pattern"/>
  <typeUsage CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <method CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="IS_VALUE_SPECIFIED" VERSION="1" LANGU="E" DESCRIPT="is the value specified?" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="IS_VALUE_SPECIFIED" SCONAME="RV_IS_VALUE_SPECIFIED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="RETURN" VERSION="1" LANGU="E" DESCRIPT="returns the registered value" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="RETURN" SCONAME="R_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
  </method>
  <method CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="RETURNS" VERSION="1" LANGU="E" DESCRIPT="registers the value" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="RETURNS" SCONAME="I_RETURN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZIF_MOCKA_MOCKER_ATTRIBUTE" CMPNAME="RETURNS" SCONAME="RO_MOCKER" VERSION="1" LANGU="E" DESCRIPT="beschreibt eine zu simulierende Methode" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_MOCKA_MOCKER"/>
  </method>
 </INTF>
 <PROG NAME="ZTEST_CL_MOCKA_FLIGHT_OBSERVER" VARCL="X" SUBC="1" RMAND="001" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="D">
    <textElement ID="R" ENTRY="Demo 1 (als Unit Test implementiert)" LENGTH="70 "/>
   </language>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Demo 1 (implemented as Unit Test)" LENGTH="33 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZTEST_CL_MOCKA_FLIGHT_OBSERVER
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

* mockA is a mocking framework for ABAP that makes creating mock implementations easier than ever before. It is Open Source.
*   lead developers:
*     Uwe Kunath - kunath.uwe[at]googlemail.com
*
*   Copyright Uwe Kunath
*    mockA can be found at https://github.com/uweku/mockA/
*
*   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.

REPORT  ztest_cl_mocka_flight_observer.
*========================================================================================================
*a manually implemented mock class might look like this. This demo shows how you can save this effort...
**----------------------------------------------------------------------*
**       CLASS lcl_flight_info DEFINITION
**----------------------------------------------------------------------*
**
**----------------------------------------------------------------------*
*CLASS lcl_flight_info DEFINITION.
*  PUBLIC SECTION.
*    INTERFACES ZIF_MOCKA_IS_IN_TIME_INFO.
*ENDCLASS.                    &quot;lcl_flight_info DEFINITION
**----------------------------------------------------------------------*
**       CLASS lcl_flight_info IMPLEMENTATION
**----------------------------------------------------------------------*
**
**----------------------------------------------------------------------*
*CLASS lcl_flight_info IMPLEMENTATION.
*  METHOD ZIF_MOCKA_IS_IN_TIME_INFO~get_delay.
*    IF iv_carrid = &apos;LH&apos; AND iv_connid = 402 AND iv_fldate = &apos;20121109&apos;.
*      rv_delay = 100.
*    ENDIF.
*    IF iv_carrid = &apos;LH&apos; AND iv_connid = 402 AND iv_fldate = &apos;2012110&apos;.
*      rv_delay = 5.
*    ENDIF.
*  ENDMETHOD.                    &quot;ZIF_MOCKA_IS_IN_TIME_INFO~get_delay
*ENDCLASS.                    &quot;lcl_flight_info IMPLEMENTATION
*
*METHOD setup.
** this call creates the flight information mockup
*  CREATE OBJECT mo_is_in_time_access TYPE lcl_flight_info.
** create an empty alert backend (we just need to track the number of method calls)
*  CREATE OBJECT mo_alert_processor_mocker TYPE lcl_alert_process.
** create the flight observer which is subject to this test
*  CREATE OBJECT mo_system_under_test
*    EXPORTING
*      io_alert_processor = mo_alert_processor
*      io_in_time_access  = mo_is_in_time_access.
*ENDMETHOD. &quot;setup
*========================================================================================================

*----------------------------------------------------------------------*
*       CLASS lcl_test_observer DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_observer DEFINITION FOR TESTING.
  &quot;#AU Risk_Level Harmless
  &quot;#AU Duration Short
  PROTECTED SECTION.

    DATA mo_is_in_time_access TYPE REF TO zif_mocka_is_in_time_info .
    DATA mo_is_in_time_mocker TYPE REF TO zif_mocka_mocker.
    DATA mo_alert_processor TYPE REF TO zif_mocka_flight_alert_process .
    DATA mo_alert_processor_mocker TYPE REF TO zif_mocka_mocker.

    DATA mo_system_under_test TYPE REF TO zcl_mocka_flight_observer.

  PRIVATE SECTION.
    METHODS setup.
    METHODS teardown.
    METHODS test_no_alert FOR TESTING.
    METHODS test_with_alert FOR TESTING.
ENDCLASS.                    &quot;lcl_test_observer DEFINITION


*----------------------------------------------------------------------*
*       CLASS lcl_test_observer IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_observer IMPLEMENTATION.
  METHOD setup.
**   Member attributes:
*    DATA mo_is_in_time_access TYPE REF TO ZIF_MOCKA_IS_IN_TIME_INFO .
*    DATA mo_is_in_time_mocker TYPE REF TO ZIF_MOCKA_MOCKER.

    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
*   create the flight information backend
    mo_is_in_time_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
    lo_mocker_method = mo_is_in_time_mocker-&gt;method( &apos;GET_DELAY&apos; ).
    lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
    lo_mocker_method-&gt;returns( 100 ).
    lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; ).
    lo_mocker_method-&gt;returns( 5 ).
*   this call creates the flight information mockup
    mo_is_in_time_access ?= mo_is_in_time_mocker-&gt;generate_mockup( ).

**   Member attributes
*    DATA mo_alert_processor TYPE REF TO ZIF_MOCKA_FLIGHT_ALERT_PROCESS .
*    DATA mo_alert_processor_mocker TYPE REF TO ZIF_MOCKA_MOCKER.

*   create an empty alert backend (we just need to track the number of method calls)
    mo_alert_processor_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_FLIGHT_ALERT_PROCESS&apos; ).
*   this call creates the alert processor mockup
    mo_alert_processor ?= mo_alert_processor_mocker-&gt;generate_mockup( ).

*   create the flight observer which is subject to this test
    CREATE OBJECT mo_system_under_test
      EXPORTING
        io_alert_processor = mo_alert_processor
        io_in_time_access  = mo_is_in_time_access.
  ENDMETHOD.                    &quot;setup
  METHOD teardown.
  ENDMETHOD.                    &quot;teardown
  METHOD test_no_alert.
    DATA lv_alert TYPE abap_bool.
    mo_system_under_test-&gt;observe_flight( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121110&apos; ).
    lv_alert = mo_alert_processor_mocker-&gt;has_method_been_called( &apos;ALERT_DELAY&apos; ).
    cl_aunit_assert=&gt;assert_initial( lv_alert ).
  ENDMETHOD.                    &quot;test_no_alert
  METHOD test_with_alert.
    DATA lv_alert TYPE abap_bool.
    mo_system_under_test-&gt;observe_flight( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
    lv_alert = mo_alert_processor_mocker-&gt;has_method_been_called( &apos;ALERT_DELAY&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lv_alert ).
  ENDMETHOD.                    &quot;test_with_alert
ENDCLASS.                    &quot;lcl_test_observer IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZTEST_CL_MOCKA_MOCKER" VARCL="X" SUBC="1" RSTAT="T" RMAND="001" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="D">
    <textElement ID="R" ENTRY="mockA Unit Tests" LENGTH="70 "/>
   </language>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="mockA Unit Tests" LENGTH="16 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZTEST_CL_MOCKA_MOCKER
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

* mockA is a mocking framework for ABAP that makes creating mock implementations easier than ever before. It is Open Source.
*   lead developers:
*     Uwe Kunath - kunath.uwe[at]googlemail.com
*
*   Copyright Uwe Kunath
*    mockA can be found at https://github.com/uweku/mockA/
*
*   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.

REPORT  ztest_cl_mocka_mocker.

TYPE-POOLS: abap.

*----------------------------------------------------------------------*
*       CLASS lcl_test_mocker DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_mocker DEFINITION FOR TESTING.
  &quot;#AU Risk_Level Harmless
  &quot;#AU Duration Short
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS setup.
    METHODS teardown.
    METHODS create_valid_mocker FOR TESTING.
    METHODS create_invalid_mocker FOR TESTING.
    METHODS create_valid_mocker_method FOR TESTING.
    METHODS create_retrieve_mocker_method FOR TESTING.
    METHODS create_invalid_mocker_method FOR TESTING.
    METHODS test_method_parameter_verif FOR TESTING.
    METHODS is_in_time FOR TESTING.
    METHODS get_delay FOR TESTING.
    METHODS get_delay_multi_importing FOR TESTING.
    METHODS get_both FOR TESTING.
    METHODS get_both_by_optional_param FOR TESTING.
    METHODS raises_exception FOR TESTING.
    METHODS raises_exception_wo_with FOR TESTING.
    METHODS raises_exception_wo_with_2 FOR TESTING.
    METHODS is_in_time_by_changing_param FOR TESTING.
    METHODS is_in_time_by_chng_param_multi FOR TESTING.
    METHODS optional_params FOR TESTING.
    METHODS get_delay_x2 FOR TESTING.
    METHODS raises_exc_x2 FOR TESTING.
    METHODS changing_parameter_x2 FOR TESTING.
    METHODS fake_included_interface_method FOR TESTING.
    METHODS method_with_old_exc FOR TESTING.
    METHODS fake_interface_attribute FOR TESTING.
    METHODS fake_instance_attribute FOR TESTING.
    METHODS fake_invalid_attribute FOR TESTING.
    METHODS is_method_called_positive FOR TESTING.
    METHODS is_method_called_negative FOR TESTING.
ENDCLASS.                    &quot;lcl_test_mocker DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_test_mocker IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_mocker IMPLEMENTATION.
  METHOD setup.
  ENDMETHOD.                    &quot;setup
  METHOD teardown.
  ENDMETHOD.                    &quot;teardown
  METHOD create_valid_mocker.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_not_initial( lo_mocker ).
  ENDMETHOD.                    &quot;create_valid_mocker
  METHOD create_invalid_mocker.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;\PROGRAM=ZTEST_CL_MOCKA_MOCKER\INTERFACE=LIF_INVALID&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_initial( lo_mocker ).
  ENDMETHOD.                    &quot;create_valid_mocker

  METHOD create_valid_mocker_method.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_not_initial( lo_mocker ).
    cl_aunit_assert=&gt;assert_not_initial( lo_mocker_method ).
  ENDMETHOD.                    &quot;create_valid_mocker_method
  METHOD create_retrieve_mocker_method.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method1 TYPE REF TO zif_mocka_mocker_method.
    DATA  lv_mm1_eq_mm2 TYPE abap_bool.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method1 = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.

*   any new method results in a new instance...
    DATA lo_mocker_method2 TYPE REF TO zif_mocka_mocker_method.
    TRY.
        lo_mocker_method2 = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
    IF lo_mocker_method1 EQ lo_mocker_method2.
      lv_mm1_eq_mm2 = abap_true.
    ELSE.
      lv_mm1_eq_mm2 = abap_false.
    ENDIF.
    cl_aunit_assert=&gt;assert_initial( lv_mm1_eq_mm2 ).

*   ...but any method which has already been requested returns the existing instance
    TRY.
        lo_mocker_method2 = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

    IF lo_mocker_method1 EQ lo_mocker_method2.
      lv_mm1_eq_mm2 = abap_true.
    ELSE.
      lv_mm1_eq_mm2 = abap_false.
    ENDIF.
    cl_aunit_assert=&gt;assert_not_initial( lv_mm1_eq_mm2 ).
  ENDMETHOD.                    &quot;create_and_retrieve_mocker_method
  METHOD create_invalid_mocker_method.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;INVALID&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_not_initial( lo_mocker ).
    cl_aunit_assert=&gt;assert_initial( lo_mocker_method ).
  ENDMETHOD.                    &quot;create_invalid_mocker_method

  METHOD test_method_parameter_verif.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = 20121108 ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

*   create invalid parameter combination
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = 20121108 i_p4 = &apos;INVALID_PARAM&apos;).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).

*   create valid parameter combination - using RETURNING parameter
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    CLEAR: lv_has_exception_been_raised.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;returns( abap_true ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

*   create valid parameter combination - using EXPORTING parameters
    CLEAR: lv_has_exception_been_raised.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_BOTH&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;exports( i_p1 = 10 i_p2 = abap_false ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

*   create invalid parameter combination - using EXPORTING parameters
    CLEAR: lv_has_exception_been_raised.
    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_BOTH&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; i_p4 = &apos;INVALID&apos; ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;test_method_parameter_verif

  METHOD is_in_time.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.
    DATA lv_flag TYPE abap_bool.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;returns( abap_true ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( abap_false ).
*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; )-&gt;returns( abap_true ).
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; )-&gt;returns( abap_false ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

*       call interface methods of the mockup - IS_IN_TIME
        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

*       verify number of calls for IS_IN_TIME
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 2 ).
        lv_flag = lo_mocker_method-&gt;has_method_been_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_flag exp = abap_true ).
        lv_flag = lo_mocker-&gt;has_any_method_been_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_flag exp = abap_true ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;mock

  METHOD get_delay.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( 10 ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; ).
        lo_mocker_method-&gt;returns( 5 ).

*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; )-&gt;returns( 10 ).
*        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; )-&gt;returns( 5 ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

*       call interface methods of the mockup - GET_DELAY
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 10 ).
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121110&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 5 ).

*       not registered calls should not lead to any exception
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121111&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 0 ).

*       verify number of calls for GET_DELAY
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 3 ).


      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
  ENDMETHOD.                    &quot;GET_DELAY

  METHOD get_delay_multi_importing.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; ).
        lo_mocker_method-&gt;returns( 5 ).

*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; )-&gt;returns( 5 ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

*       call interface methods of the mockup - GET_DELAY
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 5 ).
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121110&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 5 ).

*       verify number of calls for GET_DELAY
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 2 ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
  ENDMETHOD.                    &quot;get_delay_multi_importing

  METHOD get_both.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
*       create valid parameter combination - using EXPORTING parameters
        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_BOTH&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;exports( i_p1 = 10 i_p2 = abap_false ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;exports( i_p1 = 2 i_p2 = abap_true ).

*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; )-&gt;exports( i_p1 = 10 i_p2 = abap_false ).
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; )-&gt;exports( i_p1 = 2 i_p2 = abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        lo_in_time-&gt;get_both(
            EXPORTING iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos;
            IMPORTING ev_delay = lv_delay ev_is_in_time = lv_is_in_time ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 2 ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

        lo_in_time-&gt;get_both(
            EXPORTING iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos;
            IMPORTING ev_delay = lv_delay ev_is_in_time = lv_is_in_time ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 10 ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

        &quot;default values
        lo_in_time-&gt;get_both(
            EXPORTING iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121110&apos;
            IMPORTING ev_delay = lv_delay ev_is_in_time = lv_is_in_time ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 0 ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

*       verify number of calls for GET_BOTH
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 3 ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;get_both

  METHOD get_both_by_optional_param.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
*       create valid parameter combination - using EXPORTING parameters
        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_BOTH_BY_OPTIONAL_PARAM&apos; ).
        lo_mocker_method-&gt;exports( i_p1 = 2 i_p2 = abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        lo_in_time-&gt;get_both_by_optional_param(
            IMPORTING ev_delay = lv_delay ev_is_in_time = lv_is_in_time ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 2 ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

*       verify number of calls for GET_BOTH_BY_OPTIONAL_PARAM
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 1 ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;get_both_optional
  METHOD raises_exception.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
*       create valid parameter combination - using EXPORTING parameters
        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).

        TRY.
            lv_has_exception_been_raised = abap_false.
            lo_mocker_method-&gt;raises_by_name( &apos;CX_STATIC_CHECK&apos; ).&quot;invalid exception - is abstract
          CATCH zcx_mocka.
            lv_has_exception_been_raised = abap_true.
        ENDTRY.
        cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
        lv_has_exception_been_raised = abap_false.


        lo_mocker_method-&gt;raises_by_name( &apos;zcx_mocka_in_time_exception&apos; ).&quot;intentionally name the valid exception in lower case

        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( abap_false ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).
        TRY.
            lv_has_exception_been_raised = abap_false.
            lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
          CATCH zcx_mocka_in_time_exception.
            lv_has_exception_been_raised = abap_true.
          CATCH cx_root.
            lv_has_exception_been_raised = abap_false.&quot;since it is the wrong exception
        ENDTRY.
        cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
        lv_has_exception_been_raised = abap_false.

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;raises_exception
  METHOD raises_exception_wo_with.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.

    lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
*   create valid parameter combination - using EXPORTING parameters
    CLEAR: lv_has_exception_been_raised.
    lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
    lo_mocker_method-&gt;raises_by_name( &apos;zcx_mocka_in_time_exception&apos; ).&quot;intentionally name the valid exception in lower case

*   this call creates the mockup
    lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
    cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

    TRY.
        lv_has_exception_been_raised = abap_false.
        lo_in_time-&gt;is_in_time( ).
      CATCH zcx_mocka_in_time_exception.
        lv_has_exception_been_raised = abap_true.
      CATCH cx_root.
        lv_has_exception_been_raised = abap_false.&quot;since it is the wrong exception
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
    lv_has_exception_been_raised = abap_false.

  ENDMETHOD.                    &quot;raises_exception_wo_with

  METHOD raises_exception_wo_with_2.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lo_cx_mocka_in_time_exception TYPE REF TO zcx_mocka_in_time_exception.
    TRY.
        RAISE EXCEPTION TYPE zcx_mocka_in_time_exception.
      CATCH zcx_mocka_in_time_exception INTO lo_cx_mocka_in_time_exception.
    ENDTRY.

    lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
*   create valid parameter combination - using EXPORTING parameters
    CLEAR: lv_has_exception_been_raised.
    lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
    lo_mocker_method-&gt;raises( lo_cx_mocka_in_time_exception ).&quot;intentionally name the valid exception in lower case

*   this call creates the mockup
    lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
    cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

    TRY.
        lv_has_exception_been_raised = abap_false.
        lo_in_time-&gt;is_in_time( ).
      CATCH zcx_mocka_in_time_exception.
        lv_has_exception_been_raised = abap_true.
      CATCH cx_root.
        lv_has_exception_been_raised = abap_false.&quot;since it is the wrong exception
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).
    lv_has_exception_been_raised = abap_false.

  ENDMETHOD.                    &quot;raises_exception_wo_with_2
  METHOD is_in_time_by_chng_param_multi.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    DATA lv_fldate TYPE s_date.
    CONSTANTS lc_change_to_fldate TYPE s_date VALUE &apos;20121124&apos;.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).

        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME_BY_CHANGING_PARAM&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121108&apos; ).
        lo_mocker_method-&gt;with_changing( &apos;20121109&apos; ).
        lo_mocker_method-&gt;exports( abap_false ).

        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121123&apos; ).
        lo_mocker_method-&gt;with_changing( &apos;20121124&apos; ).
        lo_mocker_method-&gt;changes( lc_change_to_fldate ).
        lo_mocker_method-&gt;exports( abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        CLEAR: lv_has_exception_been_raised.
        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121109&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121108&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121123&apos;.

        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        cl_aunit_assert=&gt;assert_equals( act = lv_fldate exp = lc_change_to_fldate ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121124&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;is_in_time_by_chng_param_multi

  METHOD is_in_time_by_changing_param.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    DATA lv_fldate TYPE s_date.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).

        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME_BY_CHANGING_PARAM&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121108&apos; ).
        lo_mocker_method-&gt;exports( abap_false ).

        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121109&apos; ).
        lo_mocker_method-&gt;exports( abap_true ).

        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121123&apos; ).
        lo_mocker_method-&gt;changes( &apos;20121124&apos; ).
        lo_mocker_method-&gt;exports( abap_true ).

*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 )-&gt;with_changing( &apos;20121108&apos; )-&gt;exports( i_p1 = abap_false ).
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 )-&gt;with_changing( &apos;20121109&apos; )-&gt;exports( i_p1 = abap_true ).
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 )-&gt;with_changing( &apos;20121123&apos; )-&gt;changes( &apos;20121124&apos; )-&gt;exports( i_p1 = abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        CLEAR: lv_has_exception_been_raised.
        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121109&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.

        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121108&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121123&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        cl_aunit_assert=&gt;assert_equals( act = lv_fldate exp = &apos;20121124&apos; ).


      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;IS_IN_TIME_BY_CHANGING_PARAM
  METHOD optional_params.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.
    DATA lv_flag TYPE abap_bool.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_BY_OPTIONAL_PARAMS&apos; ).
*        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).&quot;intentionally left blank - should always return a specific value
        lo_mocker_method-&gt;returns( abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

*       call interface methods of the mockup - GET_BY_OPTIONAL_PARAMS
        lv_is_in_time = lo_in_time-&gt;get_by_optional_params( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        lv_is_in_time = lo_in_time-&gt;get_by_optional_params( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

*       verify number of calls for GET_BY_OPTIONAL_PARAMS
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 2 ).
        lv_flag = lo_mocker_method-&gt;has_method_been_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_flag exp = abap_true ).
        lv_flag = lo_mocker-&gt;has_any_method_been_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_flag exp = abap_true ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;optional_params
  METHOD get_delay_x2.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( 10 ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; ).
        lo_mocker_method-&gt;returns( 5 ).

*       please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121109&apos; )-&gt;returns( 10 ).
*        lo_mocker_method = lo_mocker-&gt;method( &apos;GET_DELAY&apos; )-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121110&apos; )-&gt;returns( 5 ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

*       call interface methods of the mockup - GET_DELAY
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 10 ).
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121109&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 5 ).

*       not registered calls should not lead to any exception
        lv_delay = lo_in_time-&gt;get_delay( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121111&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_delay exp = 0 ).

*       verify number of calls for GET_DELAY
        lv_times = lo_mocker_method-&gt;times_called( ).
        cl_aunit_assert=&gt;assert_equals( act = lv_times exp = 3 ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;get_delay_x2
  METHOD raises_exc_x2.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).

        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;raises_by_name( &apos;ZCX_MOCKA_IN_TIME_EXCEPTION&apos; ).&quot;intentionally name the valid exception in lower case

        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
        lo_mocker_method-&gt;returns( abap_true ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        TRY.
            lv_has_exception_been_raised = abap_false.
            lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
            cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).

          CATCH zcx_mocka_in_time_exception.
            lv_has_exception_been_raised = abap_true.
          CATCH cx_root.
            lv_has_exception_been_raised = abap_false.&quot;since it is the wrong exception
        ENDTRY.
        cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).

*       call second pattern twice
        lv_has_exception_been_raised = abap_false.
        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).

        lv_has_exception_been_raised = abap_false.
        lv_is_in_time = lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).


      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;raises_exc_x2
  METHOD changing_parameter_x2.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.

*   create valid parameter combination
    DATA lr_flag TYPE REF TO data.
    FIELD-SYMBOLS &lt;lv_flag&gt; TYPE abap_bool.
    DATA lv_is_in_time TYPE abap_bool.
    DATA lv_delay TYPE i.
    DATA lv_fldate TYPE s_date.
    CLEAR: lv_has_exception_been_raised.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.
    DATA lv_times TYPE i.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
        lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME_BY_CHANGING_PARAM&apos; ).
*       create valid parameter combination - using EXPORTING parameters
        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121123&apos; ).
        lo_mocker_method-&gt;changes( &apos;20121124&apos; ).
        lo_mocker_method-&gt;exports( abap_false ).

*       this call creates the mockup
        lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
        cl_aunit_assert=&gt;assert_not_initial( lo_in_time ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121123&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_false ).
        cl_aunit_assert=&gt;assert_equals( act = lv_fldate exp = &apos;20121124&apos; ).

        CLEAR: lv_has_exception_been_raised.
        lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 ).
        lo_mocker_method-&gt;with_changing( &apos;20121123&apos; ).
        lo_mocker_method-&gt;exports( abap_true ).

*       call second pattern twice
        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121123&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        cl_aunit_assert=&gt;assert_equals( act = lv_fldate exp = &apos;20121123&apos; ).

        CLEAR: lv_is_in_time.
        lv_fldate = &apos;20121123&apos;.
        CALL METHOD lo_in_time-&gt;is_in_time_by_changing_param
          EXPORTING
            iv_carrid     = &apos;LH&apos;
            iv_connid     = 402
          IMPORTING
            ev_is_in_time = lv_is_in_time
          CHANGING
            cv_fldate     = lv_fldate.
        cl_aunit_assert=&gt;assert_equals( act = lv_is_in_time exp = abap_true ).
        cl_aunit_assert=&gt;assert_equals( act = lv_fldate exp = &apos;20121123&apos; ).

      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;changing_parameter_x2
  METHOD fake_included_interface_method.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    DATA lo_fake TYPE REF TO if_fpm_guibb_list.
    DATA lt_param_list TYPE fpmgb_t_param_descr.
    DATA ls_param_list TYPE fpmgb_s_param_descr.
    ls_param_list-name = &apos;A&apos;.
    APPEND ls_param_list TO lt_param_list.

    lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;IF_FPM_GUIBB_LIST&apos; ).
    lo_mocker_method = lo_mocker-&gt;method( &apos;IF_FPM_GUIBB~GET_PARAMETER_LIST&apos; ).&quot;currently only works for method aliases
    lo_mocker_method-&gt;with( )-&gt;returns( lt_param_list ).

    lo_fake ?= lo_mocker-&gt;generate_mockup( ).
    CLEAR: lt_param_list.
    lt_param_list = lo_fake-&gt;if_fpm_guibb~get_parameter_list( ).
    cl_aunit_assert=&gt;assert_not_initial( lt_param_list ).

  ENDMETHOD.                    &quot;fake_included_interface_method
  METHOD method_with_old_exc.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    DATA lo_fake TYPE REF TO if_http_client.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;IF_HTTP_CLIENT&apos; ).
        lo_fake ?= lo_mocker-&gt;generate_mockup( ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;method_with_old_exc
  METHOD fake_interface_attribute.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    DATA lo_fake TYPE REF TO if_http_client.
    DATA lo_attribute TYPE REF TO zif_mocka_mocker_attribute.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;IF_HTTP_CLIENT&apos; ).
        lo_attribute = lo_mocker-&gt;attribute( &apos;PROPERTYTYPE_LOGON_POPUP&apos; ).
        lo_attribute-&gt;returns( 3 ).
        lo_fake ?= lo_mocker-&gt;generate_mockup( ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_equals( act = lo_fake-&gt;propertytype_logon_popup exp = 3 ).

  ENDMETHOD.                    &quot;attribute
  METHOD fake_instance_attribute.

    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_fake TYPE REF TO zif_mocka_mocker.
    DATA lo_attribute TYPE REF TO zif_mocka_mocker_attribute.
    DATA lv_interface TYPE seoclsname.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZCL_MOCKA_MOCKER&apos; ).
        lo_attribute = lo_mocker-&gt;attribute( &apos;MV_INTERFACE&apos; ).
        lo_attribute-&gt;returns( &apos;ZIF_TEST&apos; ).
        lo_fake ?= lo_mocker-&gt;generate_mockup( ).
        lv_interface = lo_fake-&gt;get_interface( ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_initial( lv_has_exception_been_raised ).
    cl_aunit_assert=&gt;assert_equals( act = lv_interface exp = &apos;ZIF_TEST&apos; ).

  ENDMETHOD.                    &quot;fake_static_attribute

  METHOD fake_invalid_attribute.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    DATA lo_fake TYPE REF TO if_http_client.
    DATA lo_attribute TYPE REF TO zif_mocka_mocker_attribute.

    TRY.
        lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;IF_HTTP_CLIENT&apos; ).
        lo_attribute = lo_mocker-&gt;attribute( &apos;fake_invalid_attribute&apos; ).
        lo_attribute-&gt;returns( 3 ).
        lo_fake ?= lo_mocker-&gt;generate_mockup( ).
      CATCH zcx_mocka.
        lv_has_exception_been_raised = abap_true.
    ENDTRY.
    cl_aunit_assert=&gt;assert_not_initial( lv_has_exception_been_raised ).

  ENDMETHOD.                    &quot;fake_invalid_attribute
  METHOD is_method_called_positive.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.

    DATA lv_has_been_called TYPE abap_bool.

    lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
    lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
    lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
    lo_mocker_method-&gt;returns( abap_true ).
*   please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*    lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; )-&gt;returns( abap_true ).

*   this call creates the mockup
    lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
    lv_has_been_called = lo_mocker_method-&gt;has_been_called_with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
    cl_aunit_assert=&gt;assert_initial( lv_has_been_called ).
*   call interface methods of the mockup - IS_IN_TIME
    lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).

    lv_has_been_called = lo_mocker_method-&gt;has_been_called_with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lv_has_been_called ).

  ENDMETHOD.                    &quot;is_method_called_positive

  METHOD is_method_called_negative.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    DATA lo_in_time TYPE REF TO zif_mocka_is_in_time_info.

    DATA lv_has_been_called TYPE abap_bool.

    lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
    lo_mocker_method = lo_mocker-&gt;method( &apos;IS_IN_TIME&apos; ).
    lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; ).
    lo_mocker_method-&gt;returns( abap_true ).
*   please be aware of fluent API: in NW releases &gt;= 7.02 you could also use:
*    lo_mocker_method-&gt;with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20121108&apos; )-&gt;returns( abap_true ).

*   this call creates the mockup
    lo_in_time ?= lo_mocker-&gt;generate_mockup( ).
    lv_has_been_called = lo_mocker_method-&gt;has_been_called_with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20140624&apos; ).
    cl_aunit_assert=&gt;assert_initial( lv_has_been_called ).&quot;initial as the method IS_IN_TIME has not yet been called with the requested parameters
*   call interface methods of the mockup - IS_IN_TIME
    lo_in_time-&gt;is_in_time( iv_carrid = &apos;LH&apos; iv_connid = 402 iv_fldate = &apos;20121108&apos; ).

    lv_has_been_called = lo_mocker_method-&gt;has_been_called_with( i_p1 = &apos;LH&apos; i_p2 = 402 i_p3 = &apos;20140624&apos; ).
    cl_aunit_assert=&gt;assert_initial( lv_has_been_called ).&quot;initial as the method IS_IN_TIME has still not been called with the requested parameters

  ENDMETHOD.                    &quot;is_method_called_negative
ENDCLASS.                    &quot;lcl_test_mocker IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZMOCKA_DEMO" VARCL="X" SUBC="1" RSTAT="T" RMAND="001" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="D">
    <textElement ID="R" ENTRY="Demo 2 (als Testprogramm implementiert)" LENGTH="70 "/>
   </language>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Demo 2 (implemented as test report)" LENGTH="35 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZMOCKA_DEMO
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

* mockA is a mocking framework for ABAP that makes creating mock implementations easier than ever before. It is Open Source.
*   lead developers:
*     Uwe Kunath - kunath.uwe[at]googlemail.com
*
*   Copyright Uwe Kunath
*    mockA can be found at https://github.com/uweku/mockA/
*
*   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.

REPORT  zmocka_demo.

DATA lo_mocker TYPE REF TO zif_mocka_mocker.
DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( zif_mocka_is_in_time_info=&gt;gc_name ).

DATA lo_is_in_time_into TYPE REF TO zif_mocka_is_in_time_info.
DATA lv_delay TYPE i.
DATA lv_has_been_called TYPE abap_bool.
DATA lv_call_count TYPE i.

lo_mocker_method = lo_mocker-&gt;method( &apos;get_delay&apos; ).
lo_mocker_method-&gt;with(
    i_p1             = &apos;LH&apos;
    i_p2             = &apos;300&apos;
    i_p3             = sy-datlo
).
lo_mocker_method-&gt;returns( 100 ).

*in NW &gt;= 7.02 you may also use:
*lo_mocker-&gt;method( &apos;get_delay&apos; )-&gt;with(
*    i_p1             = &apos;LH&apos;
*    i_p2             = &apos;300&apos;
*    i_p3             = sy-datlo
*)-&gt;returns( 100 ).

lo_is_in_time_into ?= lo_mocker-&gt;generate_mockup( ).
lv_has_been_called = lo_mocker-&gt;has_method_been_called( &apos;get_delay&apos; ).
WRITE: &apos;get_delay( ) called? -&gt; &quot;&apos;, lv_has_been_called, &apos;&quot; (&quot;X&quot;=yes, &quot;&quot;=no)&apos;.&quot;#EC NOTEXT
NEW-LINE.
lo_mocker_method = lo_mocker-&gt;method( &apos;get_delay&apos; ).
lv_has_been_called = lo_mocker_method-&gt;has_been_called_with(
    i_p1             = &apos;LH&apos;
    i_p2             = &apos;300&apos;
    i_p3             = sy-datlo
).
WRITE: &apos;get_delay( ) called with LH/300&apos;,sy-datlo,&apos;? -&gt; &quot;&apos;, lv_has_been_called, &apos;&quot; (&quot;X&quot;=yes, &quot;&quot;=no)&apos;.&quot;#EC NOTEXT
NEW-LINE.

lo_is_in_time_into-&gt;get_delay(
  EXPORTING
    iv_carrid = &apos;LH&apos;
    iv_connid = &apos;300&apos;
    iv_fldate = sy-datlo
  RECEIVING
    rv_delay  = lv_delay
).
WRITE: &apos;get_delay( ) for LH/300&apos;,sy-datlo,&apos;: &apos;, lv_delay.&quot;#EC NOTEXT
NEW-LINE.

lv_has_been_called = lo_mocker-&gt;has_method_been_called( &apos;get_delay&apos; ).
WRITE: &apos;get_delay( ) called? -&gt; &quot;&apos;, lv_has_been_called, &apos;&quot; (&quot;X&quot;=yes, &quot;&quot;=no)&apos;.&quot;#EC NOTEXT
NEW-LINE.
lv_call_count = lo_mocker-&gt;method_call_count( &apos;get_delay&apos; ).
WRITE: &apos;call count of get_delay( ) :&apos;, lv_call_count.&quot;#EC NOTEXT
NEW-LINE.

lo_mocker_method = lo_mocker-&gt;method( &apos;get_delay&apos; ).
lv_has_been_called = lo_mocker_method-&gt;has_been_called_with(
    i_p1             = &apos;LH&apos;
    i_p2             = &apos;300&apos;
    i_p3             = sy-datlo
).
WRITE: &apos;get_delay( ) called with LH/300&apos;,sy-datlo,&apos;? -&gt; &quot;&apos;, lv_has_been_called, &apos;&quot; (&quot;X&quot;=yes, &quot;&quot;=no)&apos;.&quot;#EC NOTEXT
NEW-LINE.

lv_has_been_called = lo_mocker_method-&gt;has_been_called_with(
    i_p1             = &apos;LH&apos;
    i_p2             = &apos;301&apos;
    i_p3             = sy-datlo
).
WRITE: &apos;get_delay( ) called with LH/301&apos;,sy-datlo,&apos;? -&gt; &quot;&apos;, lv_has_been_called, &apos;&quot; (&quot;X&quot;=yes, &quot;&quot;=no)&apos;.&quot;#EC NOTEXT</source>
 </PROG>
 <PROG NAME="ZTEST_CL_MOCKA_CLASS_GEN" VARCL="X" SUBC="1" RSTAT="T" RMAND="001" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="D">
    <textElement ID="R" ENTRY="mockA Unit Tests" LENGTH="70 "/>
   </language>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="mockA Unit Tests" LENGTH="16 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZTEST_CL_MOCKA_CLASS_GEN
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

* mockA is a mocking framework for ABAP that makes creating mock implementations easier than ever before. It is Open Source.
*   lead developers:
*     Uwe Kunath - kunath.uwe[at]googlemail.com
*
*   Copyright Uwe Kunath
*    mockA can be found at https://github.com/uweku/mockA/
*
*   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.

REPORT  ztest_cl_mocka_class_gen.

TYPE-POOLS: abap.

*----------------------------------------------------------------------*
*       CLASS lcl_transparent_mocker DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_transparent_mocker DEFINITION INHERITING FROM zcl_mocka_mocker.
  PUBLIC SECTION.
    CLASS-METHODS mock_by_subclass
    IMPORTING
      !iv_interface TYPE abap_abstypename
    RETURNING
      value(ro_mocker) TYPE REF TO zif_mocka_mocker.
    METHODS get_current_generated_class
      RETURNING
        value(rv_name) TYPE abap_abstypename.
ENDCLASS.                    &quot;lcl_transparent_mocker DEFINITION
*----------------------------------------------------------------------*
*       CLASS lcl_transparent_mocker IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_transparent_mocker IMPLEMENTATION.
  METHOD mock_by_subclass.
*   returns a new mock object instance that provides the root object for recording &amp; generating the mock object behaviour
*   for this unit test, an instance of type lcl_transparent_mocker will be created which gives us access to the protected attribute &quot;mv_generated_class&quot;
    DATA lo_mocker TYPE REF TO lcl_transparent_mocker.
    DATA lo_typedescr TYPE REF TO cl_abap_typedescr.
    DATA lo_cx_root TYPE REF TO cx_root.
    DATA lv_message TYPE string.
    FIELD-SYMBOLS &lt;ls_method&gt; TYPE abap_methdescr.
    DATA lv_interface LIKE iv_interface.

    check_unit_test_execution( ).

    lv_interface = iv_interface.
    TRANSLATE lv_interface TO UPPER CASE.

    CREATE OBJECT lo_mocker.

    CALL METHOD cl_abap_intfdescr=&gt;describe_by_name
      EXPORTING
        p_name         = lv_interface
      RECEIVING
        p_descr_ref    = lo_typedescr
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2.
    IF sy-subrc NE 0.
      RAISE EXCEPTION TYPE zcx_mocka
        EXPORTING
          textid    = zcx_mocka=&gt;no_such_interface
          interface = iv_interface.
    ENDIF.

    IF lo_typedescr-&gt;type_kind = cl_abap_typedescr=&gt;typekind_class.
      lo_mocker-&gt;mv_is_interface_mock = abap_false.
    ELSE.
      lo_mocker-&gt;mv_is_interface_mock = abap_true.
    ENDIF.

    TRY.
        ro_mocker = lo_mocker.
        lo_mocker-&gt;mo_objectdescr ?= lo_typedescr.
        lo_mocker-&gt;mv_interface = lv_interface.
        LOOP AT lo_mocker-&gt;mo_objectdescr-&gt;methods ASSIGNING &lt;ls_method&gt;.
          lo_mocker-&gt;resolve_method( &lt;ls_method&gt; ).
        ENDLOOP.

        DATA ls_generated_class TYPE ty_s_generated_class.
        READ TABLE mt_generated_classes INTO ls_generated_class WITH KEY name = lv_interface.
        IF sy-subrc = 0.
          lo_mocker-&gt;mv_generated_class = ls_generated_class-technical_name.
        ENDIF.
      CATCH cx_root INTO lo_cx_root.
        lv_message = lo_cx_root-&gt;get_text( ).
        RAISE EXCEPTION TYPE zcx_mocka
          EXPORTING
            textid       = zcx_mocka=&gt;zcx_mocka
            generic_text = lv_message.
    ENDTRY.
  ENDMETHOD.                    &quot;mock_by_subclass
  METHOD get_current_generated_class.
    rv_name = mv_generated_class.
  ENDMETHOD.                    &quot;get_current_generated_class
ENDCLASS.                    &quot;lcl_transparent_mocker IMPLEMENTATION
*----------------------------------------------------------------------*
*       CLASS lcl_test_mocker DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_mocker DEFINITION FOR TESTING.
  &quot;#AU Risk_Level Harmless
  &quot;#AU Duration Short
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS setup.
    METHODS teardown.
    METHODS do_not_reuse_class_impl FOR TESTING.
    METHODS reuse_interface_impl FOR TESTING.
    METHODS mock_protected_method FOR TESTING.
ENDCLASS.                    &quot;lcl_test_mocker DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_test_mocker IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_test_mocker IMPLEMENTATION.
  METHOD setup.
  ENDMETHOD.                    &quot;setup
  METHOD teardown.
  ENDMETHOD.                    &quot;teardown
  METHOD reuse_interface_impl.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_transparent_mocker TYPE REF TO lcl_transparent_mocker.
    DATA lv_generated_class1 TYPE abap_abstypename.
    DATA lv_generated_class2 TYPE abap_abstypename.

    lo_mocker = lcl_transparent_mocker=&gt;mock_by_subclass( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
    lo_transparent_mocker ?= lo_mocker.
    lo_mocker-&gt;generate_mockup( ).
    lv_generated_class1 = lo_transparent_mocker-&gt;get_current_generated_class( ).

    lo_mocker = lcl_transparent_mocker=&gt;mock_by_subclass( iv_interface = &apos;ZIF_MOCKA_IS_IN_TIME_INFO&apos; ).
    lo_transparent_mocker ?= lo_mocker.
    lo_mocker-&gt;generate_mockup( ).
    lv_generated_class2 = lo_transparent_mocker-&gt;get_current_generated_class( ).

    cl_aunit_assert=&gt;assert_equals(
      EXPORTING
        exp                  = lv_generated_class1
        act                  = lv_generated_class2
    ).
  ENDMETHOD.                    &quot;reuse_interface_implementations

  METHOD do_not_reuse_class_impl.
    DATA lv_has_exception_been_raised TYPE abap_bool VALUE abap_false.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_transparent_mocker TYPE REF TO lcl_transparent_mocker.
    DATA lv_generated_class1 TYPE abap_abstypename.
    DATA lv_generated_class2 TYPE abap_abstypename.
    lo_mocker = lcl_transparent_mocker=&gt;mock_by_subclass( iv_interface = &apos;ZCL_MOCKA_MOCKER&apos; ).
    lo_transparent_mocker ?= lo_mocker.
    lo_mocker-&gt;generate_mockup( ).
    lv_generated_class1 = lo_transparent_mocker-&gt;get_current_generated_class( ).

    lo_mocker = lcl_transparent_mocker=&gt;mock_by_subclass( iv_interface = &apos;ZCL_MOCKA_MOCKER&apos; ).
    lo_transparent_mocker ?= lo_mocker.
    lo_mocker-&gt;generate_mockup( ).
    lv_generated_class2 = lo_transparent_mocker-&gt;get_current_generated_class( ).

    cl_aunit_assert=&gt;assert_differs(
      EXPORTING
        exp                  = lv_generated_class1
        act                  = lv_generated_class2
    ).
  ENDMETHOD.                    &quot;do_not_reuse_class_impl

  METHOD mock_protected_method.
    DATA lo_mocker TYPE REF TO zif_mocka_mocker.
    DATA lo_mocker_method TYPE REF TO zif_mocka_mocker_method.
    lo_mocker = zcl_mocka_mocker=&gt;zif_mocka_mocker~mock( &apos;ZCL_MOCKA_MOCKER&apos; ).
    lo_mocker_method = lo_mocker-&gt;method( &apos;CHECK_UNIT_TEST_EXECUTION&apos; ).
    lo_mocker_method-&gt;returns( abap_false ).

    lo_mocker ?= lo_mocker-&gt;generate_mockup( ).&quot;should not cause an exception
    cl_abap_unit_assert=&gt;assert_not_initial( lo_mocker ).
  ENDMETHOD.                    &quot;mock_protected_method
ENDCLASS.                    &quot;lcl_test_mocker IMPLEMENTATION</source>
 </PROG>
 <MSAG ARBGB="ZMOCKA_EXC_MOCK" MASTERLANG="E" RESPUSER="KUNATHU">
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="000" TEXT="&amp;1"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="000" TEXT="&amp;1"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="001" TEXT="Ungültige Anzahl an Parametern übergeben"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="001" TEXT="Invalid parameter count in method call"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="002" TEXT="Das Interface &amp;1 ist unbekannt"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="002" TEXT="The interface &amp;1 is unknown"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="003" TEXT="Die Methode &amp;1 des Interfaces &amp;2 ist unbekannt"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="003" TEXT="Method &amp;1 of interface &amp;2 is unknown"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="004" TEXT="Die Methode &amp;1 des Interfaces &amp;2 besitzt keine EXPORTING-Parameter"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="004" TEXT="Method &amp;1 of interface &amp;2 has no EXPORTING parameters"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="005" TEXT="Die Methode &amp;1 des Interfaces &amp;2 besitzt keine RETURNING-Parameter"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="005" TEXT="Method &amp;1 of interface &amp;2 has no RETURNING parameters"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="006" TEXT="Die Ausnahme &amp;1 existiert nicht für die Methode &amp;2 des Interfaces &amp;2"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="006" TEXT="Exception &amp;1 not known in method &amp;2 of interface &amp;3"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="007" TEXT="&amp;1 ist keine gültige Exception-Klasse"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="007" TEXT="&amp;1 is not a valid exception class"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="008" TEXT="&amp;1 ist eine abstrakte Exception-Klasse und kann nicht verwendet"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="008" TEXT="&amp;1 is an abstract exception class and cannot be used"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="009" TEXT="Die Methode &amp;1 des Interfaces &amp;2 besitzt keine CHANGING-Parameter"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="009" TEXT="Method &amp;1 of interface &amp;2 has no CHANGING parameters"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="010" TEXT="Unit Tests können nicht ausgeführt werden. Siehe SAUNIT_CLIENT_SETUP"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="010" TEXT="Unit Test execution is not allowed in this client=&gt;Tx SAUNIT_CLIENT_SETUP"/>
  <t100 SPRSL="D" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="011" TEXT="Attribut &amp;1 ist im Interface &amp;2 nicht bekannt"/>
  <t100 SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" MSGNR="011" TEXT="Attribute &amp;1 of interface &amp;2 is unknown"/>
  <t100t SPRSL="E" ARBGB="ZMOCKA_EXC_MOCK" STEXT="Message class for exception texts (ZCX_MOCKA)"/>
 </MSAG>
</nugget>
